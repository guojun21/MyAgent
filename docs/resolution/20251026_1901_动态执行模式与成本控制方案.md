# 动态执行模式与成本控制方案

> 创建时间：2025-10-26 19:01  
> 状态：待实施  
> 优先级：P1（中高优先级）

---

## 📋 创新点

**用户可调节的执行模式 + 实时成本预估 + Token预算控制**

这是一个将"性能/成本/质量"控制权交给用户的创新设计，同时通过智能建议降低用户选择成本。

---

## 🎨 UI设计方案

### 主界面模式选择器

```
┌─────────────────────────────────────────────────────┐
│  🚀 执行模式                                         │
│  ━━━━━━━━━●━━━━━━━━━━━━━━━━━━━━━━━                │
│  🏃 轻量    ⚖️ 标准    🧠 深度                      │
│  Fast     Balanced   Thorough                      │
│                                                     │
│  当前模式：⚖️ 标准模式                              │
│  • 最大迭代: 20次                                   │
│  • Token预算: 80K                                   │
│  • 预估成本: ¥0.08/次                               │
│  • 预估时间: 30-60秒                                │
│                                                     │
│  [⚙️ 高级设置]                                      │
└─────────────────────────────────────────────────────┘
```

### 高级设置面板（可折叠）

```
┌─────────────────────────────────────────────────────┐
│  ⚙️ 高级设置                                        │
├─────────────────────────────────────────────────────┤
│                                                     │
│  最大迭代次数                                        │
│  5 ━━━━━━━━━●━━━━━━━━━ 50        [20]            │
│                                                     │
│  Token预算限制（K）                                  │
│  10 ━━━━━━━━━━━●━━━━━━ 200       [80K]           │
│                                                     │
│  思考工具                                           │
│  ○ 禁用  ● 可选  ○ 强制                            │
│                                                     │
│  工具调用激进度                                      │
│  保守 ━━━━━●━━━━━ 激进                             │
│                                                     │
│  ┌───────────────────────────────────────────┐    │
│  │ 💰 实时预估                                │    │
│  │ 当前配置预计消耗：                          │    │
│  │ • Token: 60-90K                           │    │
│  │ • 成本: ¥0.06-0.12                        │    │
│  │ • 时间: 35-55秒                            │    │
│  └───────────────────────────────────────────┘    │
│                                                     │
│  [重置为默认]  [保存配置]                           │
└─────────────────────────────────────────────────────┘
```

---

## 🎯 三档预设模式

### 🏃 轻量模式（Fast）

```python
FastModeConfig = {
    "max_iterations": 10,
    "max_token_budget": 30000,
    "max_rounds": 2,           # Plan-Execute-Think最多2轮
    "steps_per_round": 3,      # 每轮最多3个步骤
    "enable_thinking": False,  # 禁用think工具
    "tool_choice_strategy": "conservative",
    "temperature": 0.3,
    "estimated_cost": 0.02,
    "estimated_time": 15,
    "适合场景": [
        "查看文件",
        "简单搜索",
        "单个文件修改",
        "配置查询"
    ]
}
```

### ⚖️ 标准模式（Balanced）⭐ 默认

```python
BalancedModeConfig = {
    "max_iterations": 20,
    "max_token_budget": 80000,
    "max_rounds": 3,
    "steps_per_round": 6,
    "enable_thinking": True,
    "tool_choice_strategy": "auto",
    "temperature": 0.7,
    "estimated_cost": 0.08,
    "estimated_time": 45,
    "适合场景": [
        "代码重构",
        "多文件修改",
        "中等复杂调试",
        "项目分析"
    ]
}
```

### 🧠 深度模式（Thorough）

```python
ThoroughModeConfig = {
    "max_iterations": 30,
    "max_token_budget": 150000,
    "max_rounds": 5,
    "steps_per_round": 8,
    "enable_thinking": True,   # 强制每轮think
    "tool_choice_strategy": "aggressive",
    "temperature": 0.9,
    "estimated_cost": 0.20,
    "estimated_time": 90,
    "适合场景": [
        "架构设计",
        "复杂Bug修复",
        "全项目重构",
        "深度分析"
    ]
}
```

---

## 💻 后端实现

### 1. 模式管理类

```python
# core/execution_modes.py
from enum import Enum
from dataclasses import dataclass

@dataclass
class ExecutionConfig:
    """执行配置"""
    max_iterations: int
    max_token_budget: int
    max_rounds: int
    steps_per_round: int
    enable_thinking: bool
    temperature: float
    estimated_cost: float
    estimated_time: int

class ExecutionMode(Enum):
    FAST = "fast"
    BALANCED = "balanced"
    THOROUGH = "thorough"
    CUSTOM = "custom"

# 预设配置
PRESET_CONFIGS = {
    ExecutionMode.FAST: ExecutionConfig(...),
    ExecutionMode.BALANCED: ExecutionConfig(...),
    ExecutionMode.THOROUGH: ExecutionConfig(...),
}
```

### 2. Agent集成

```python
class Agent:
    def __init__(self, workspace_root: str = "."):
        ...
        self.execution_mode = ExecutionMode.BALANCED
        self.config = PRESET_CONFIGS[self.execution_mode]
        self.max_iterations = self.config.max_iterations
        self.token_budget = self.config.max_token_budget
    
    def set_mode(self, mode: ExecutionMode):
        """切换执行模式"""
        self.execution_mode = mode
        self.config = PRESET_CONFIGS[mode]
        self.max_iterations = self.config.max_iterations
        self.token_budget = self.config.max_token_budget
        print(f"切换到 {mode.value} 模式")
    
    def set_custom_config(self, max_iterations: int, token_budget: int):
        """自定义配置"""
        self.execution_mode = ExecutionMode.CUSTOM
        self.max_iterations = max_iterations
        self.token_budget = token_budget
    
    async def run(self, user_message, context_history):
        # 检查Token预算
        estimated_tokens = estimate_tokens(messages)
        if estimated_tokens > self.token_budget:
            return {
                "success": False,
                "message": f"预估token({estimated_tokens})超出预算({self.token_budget})，请降低模式或增加预算"
            }
        
        # 使用配置的max_rounds
        max_rounds = self.config.max_rounds
        
        ...
```

---

## 🎨 前端实现

### 1. 模式选择组件

```javascript
class ExecutionModeSelector {
    constructor() {
        this.currentMode = 'balanced';
        this.customConfig = null;
    }
    
    selectMode(mode) {
        this.currentMode = mode;
        
        // 调用后端切换模式
        agentBridge.setExecutionMode(mode);
        
        // 更新UI显示
        this.updateEstimates(mode);
    }
    
    updateEstimates(mode) {
        const config = MODE_CONFIGS[mode];
        
        document.getElementById('est-iterations').textContent = config.max_iterations;
        document.getElementById('est-cost').textContent = `¥${config.estimated_cost.toFixed(2)}`;
        document.getElementById('est-time').textContent = `${config.estimated_time}秒`;
    }
    
    setCustom(iterations, budget) {
        // 自定义配置
        agentBridge.setCustomConfig(iterations, budget);
        
        // 计算预估
        const estimated_cost = (budget / 1000) * 0.001;
        const estimated_time = iterations * 3;
        
        this.updateEstimates({
            max_iterations: iterations,
            estimated_cost: estimated_cost,
            estimated_time: estimated_time
        });
    }
}
```

### 2. 智能模式推荐

```javascript
function suggestMode(userMessage) {
    // 简单任务
    const simpleKeywords = ['查看', '读取', '列出', '显示'];
    if (simpleKeywords.some(k => userMessage.includes(k))) {
        showSuggestion('fast', '检测到简单任务，建议使用轻量模式');
    }
    
    // 复杂任务
    const complexKeywords = ['重构', '全部', '所有', '深度分析', '优化'];
    if (complexKeywords.some(k => userMessage.includes(k))) {
        showSuggestion('thorough', '检测到复杂任务，建议使用深度模式');
    }
}

function showSuggestion(mode, reason) {
    // 显示提示框
    const toast = `
        <div class="mode-suggestion">
            💡 ${reason}
            <button onclick="acceptSuggestion('${mode}')">采纳建议</button>
            <button onclick="dismissSuggestion()">保持当前</button>
        </div>
    `;
    showToast(toast);
}
```

---

## 📊 实时成本监控

### 对话中的实时显示

```
┌─────────────────────────────────────────┐
│  📊 当前对话统计                         │
├─────────────────────────────────────────┤
│  已用Token: 45.2K / 80K (56%)           │
│  █████████████░░░░░░░                   │
│                                         │
│  已用迭代: 12 / 20 (60%)                │
│  ████████████░░░░░░░░                   │
│                                         │
│  已用成本: ¥0.048                       │
│  预计总成本: ¥0.086                     │
│                                         │
│  执行时间: 28秒                          │
│  预计剩余: ~15秒                         │
└─────────────────────────────────────────┘
```

---

## 🎯 进阶功能：预算锁定

### 用户场景

```
用户设置：
  "每次对话最多花费 ¥0.10"
  "每天最多花费 ¥5.00"

系统行为：
  - 对话开始前预估成本
  - 超预算自动降级模式或拒绝执行
  - 达到每日限额时提示用户
```

### 实现

```python
class BudgetController:
    def __init__(self):
        self.daily_budget = 5.0  # 每日¥5
        self.per_task_budget = 0.10  # 每次¥0.1
        self.daily_spent = 0.0
    
    def check_budget(self, estimated_cost: float) -> tuple[bool, str]:
        """检查预算"""
        
        # 单次预算检查
        if estimated_cost > self.per_task_budget:
            return False, f"预估成本(¥{estimated_cost:.2f})超出单次预算(¥{self.per_task_budget})"
        
        # 每日预算检查
        if self.daily_spent + estimated_cost > self.daily_budget:
            return False, f"今日预算不足(已用¥{self.daily_spent:.2f}/¥{self.daily_budget})"
        
        return True, "预算充足"
    
    def suggest_mode_by_budget(self, task_complexity: str) -> ExecutionMode:
        """根据预算建议模式"""
        remaining = self.per_task_budget - (self.daily_spent % self.per_task_budget)
        
        if remaining < 0.05:
            return ExecutionMode.FAST
        elif remaining < 0.15:
            return ExecutionMode.BALANCED
        else:
            return ExecutionMode.THOROUGH
```

---

## 🎨 用户体验流程

### 场景1：智能推荐

```
用户输入："帮我重构整个认证系统"
  ↓
系统分析：
  - 关键词"重构"、"整个"→ 复杂任务
  - 当前模式：标准(20步)
  - 预估需要：25-30步
  ↓
弹出提示：
┌────────────────────────────────────────┐
│ 💡 任务复杂度分析                       │
│                                        │
│ 检测到复杂任务，建议使用 🧠 深度模式    │
│                                        │
│ 标准模式 vs 深度模式：                  │
│ • 迭代次数: 20 → 30                    │
│ • 成功率: 65% → 90%                    │
│ • 成本: ¥0.08 → ¥0.20 (+¥0.12)        │
│                                        │
│ [采用深度模式] [保持标准模式]           │
└────────────────────────────────────────┘
```

### 场景2：预算预警

```
执行中途：
┌────────────────────────────────────────┐
│ ⚠️ 预算预警                            │
│                                        │
│ Token使用已达70% (56K/80K)             │
│                                        │
│ 建议操作：                              │
│ • 继续执行（可能超预算）                │
│ • 立即总结并结束                        │
│ • 切换到轻量模式完成剩余任务             │
│                                        │
│ [继续] [总结结束] [切换模式]            │
└────────────────────────────────────────┘
```

---

## 📊 数据持久化

### 用户配置存储

```json
// data/user_preferences.json
{
    "execution_preferences": {
        "default_mode": "balanced",
        "custom_configs": {
            "max_iterations": 20,
            "token_budget": 80000
        },
        "budget_limits": {
            "per_task": 0.10,
            "daily": 5.00,
            "monthly": 100.00
        },
        "auto_suggestion": true,  // 是否启用智能推荐
        "cost_alerts": true       // 是否启用成本预警
    },
    "usage_statistics": {
        "total_tasks": 156,
        "total_cost": 12.48,
        "avg_cost_per_task": 0.08,
        "mode_distribution": {
            "fast": 45,
            "balanced": 98,
            "thorough": 13
        }
    }
}
```

---

## 🔢 成本计算公式

### Token成本计算

```python
def calculate_cost(prompt_tokens: int, completion_tokens: int) -> float:
    """计算单次对话成本（DeepSeek价格）"""
    
    # DeepSeek价格（2025年）
    INPUT_PRICE = 0.001   # ¥0.001 / 1K tokens
    OUTPUT_PRICE = 0.002  # ¥0.002 / 1K tokens
    
    input_cost = (prompt_tokens / 1000) * INPUT_PRICE
    output_cost = (completion_tokens / 1000) * OUTPUT_PRICE
    
    return input_cost + output_cost

def estimate_cost_by_mode(mode: ExecutionMode, task_complexity: str) -> tuple[float, float]:
    """预估成本范围"""
    
    base_cost = MODE_CONFIGS[mode].estimated_cost
    
    # 根据任务复杂度调整
    complexity_multiplier = {
        "simple": 0.5,
        "medium": 1.0,
        "complex": 1.5
    }
    
    multiplier = complexity_multiplier.get(task_complexity, 1.0)
    min_cost = base_cost * multiplier * 0.7
    max_cost = base_cost * multiplier * 1.3
    
    return (min_cost, max_cost)
```

---

## 🎨 可视化统计面板

### 成本分析Dashboard

```
┌─────────────────────────────────────────────────────┐
│  📊 使用统计                                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│  本周消耗：¥2.34 / ¥35.00 预算                      │
│  ██████░░░░░░░░░░░░░░░░░░░░░░░░░░ 6.7%             │
│                                                     │
│  模式分布：                                          │
│  🏃 轻量: 23次 (45%)  ¥0.46                         │
│  ⚖️ 标准: 25次 (49%)  ¥1.76                        │
│  🧠 深度: 3次  (6%)   ¥0.12                         │
│                                                     │
│  Token消耗趋势：                                     │
│  [折线图：最近7天每日token消耗]                      │
│                                                     │
│  成本优化建议：                                      │
│  • 45%的任务可降级到轻量模式，节省¥0.8              │
│  • 考虑批量操作减少对话次数                          │
└─────────────────────────────────────────────────────┘
```

---

## 🚀 智能优化：自适应模式

### 学习用户习惯

```python
class AdaptiveModeSelector:
    """自适应模式选择器"""
    
    def __init__(self):
        self.task_history = []  # 任务历史
    
    def learn_from_history(self, task: str, mode: str, success: bool, actual_iterations: int):
        """从历史中学习"""
        self.task_history.append({
            "task": task,
            "mode": mode,
            "success": success,
            "actual_iterations": actual_iterations
        })
    
    def suggest_optimal_mode(self, new_task: str) -> ExecutionMode:
        """基于历史推荐最优模式"""
        
        # 找相似任务
        similar_tasks = find_similar(new_task, self.task_history)
        
        if not similar_tasks:
            return ExecutionMode.BALANCED  # 默认
        
        # 统计最成功的模式
        mode_success_rate = {}
        for task in similar_tasks:
            mode = task["mode"]
            if mode not in mode_success_rate:
                mode_success_rate[mode] = {"success": 0, "total": 0}
            
            mode_success_rate[mode]["total"] += 1
            if task["success"]:
                mode_success_rate[mode]["success"] += 1
        
        # 选择成功率最高的模式
        best_mode = max(
            mode_success_rate.items(),
            key=lambda x: x[1]["success"] / x[1]["total"]
        )[0]
        
        return ExecutionMode(best_mode)
```

---

## 🎯 实施路线图

### Phase 1: 基础模式切换（2天）
- [ ] 定义3个预设模式配置
- [ ] Agent支持模式切换
- [ ] 前端UI：3个按钮选择
- [ ] Qt Bridge集成

### Phase 2: 高级设置（1天）
- [ ] 滑块调节迭代/预算
- [ ] 实时成本预估
- [ ] 配置持久化

### Phase 3: 智能推荐（2天）
- [ ] 任务复杂度分析
- [ ] 自动推荐模式
- [ ] 预算预警

### Phase 4: 数据统计（1天）
- [ ] 使用统计Dashboard
- [ ] 成本分析
- [ ] 优化建议

---

## 💡 创新亮点总结

1. ✅ **用户可控**：3档+自定义，满足不同需求
2. ✅ **成本透明**：实时预估+统计分析
3. ✅ **智能辅助**：自动推荐合适模式
4. ✅ **预算保护**：硬性限制防止爆炸
5. ✅ **学习优化**：从历史中学习最优配置

**这套方案可以成为产品的核心差异化feature！** 🌟

---

## 📈 预期收益

| 指标 | 当前 | 实施后 | 提升 |
|------|-----|--------|------|
| 平均成本/任务 | ¥0.15 | ¥0.06 | ⬇️ 60% |
| Token浪费率 | 40% | 15% | ⬇️ 62% |
| 用户满意度 | 70% | 90% | ⬆️ 29% |
| 任务完成率 | 65% | 85% | ⬆️ 31% |

**投入1周，节省长期成本60%，值得！** 💰🚀

