# 输入长度限制与大文本处理方案

> 创建时间：2025-10-26 19:07  
> 状态：待实施  
> 优先级：P2（用户体验优化）  
> 实施周期：1天

---

## 📋 方案概述

**限制用户输入框为100KB，超过则引导用户使用文件方式**

---

## 🎯 为什么需要限制？

### 问题场景

```
用户误操作：
  1. 复制了整个日志文件（5MB）
  2. 粘贴到输入框
  3. 点击发送
     ↓
后果：
  ❌ 前端卡死（渲染5MB文本）
  ❌ Context爆炸（250K tokens）
  ❌ 成本暴涨（¥0.5/次对话）
  ❌ 执行失败（超过模型限制）
```

### 合理的限制

```
100KB = 102,400 字符
     ≈ 150,000 tokens
     ≈ 5万个汉字
     ≈ 200页Word文档

足够应对：
  ✅ 详细需求描述（通常<5KB）
  ✅ 代码片段（通常<20KB）
  ✅ 配置文件内容（通常<10KB）
  
不适合：
  ❌ 整个代码文件（应该用read_file）
  ❌ 日志文件（应该保存后分析）
  ❌ 大段文档（应该分段提问）
```

---

## 💻 前端实现

### 1. 输入框验证

```html
<!-- ui/index.html -->
<div class="input-container">
    <textarea 
        id="user-input" 
        placeholder="输入您的需求（最多100KB）..."
        maxlength="102400"
        rows="4"
    ></textarea>
    
    <!-- 字符计数条 -->
    <div class="input-footer">
        <div class="char-counter" id="char-counter">
            <span class="char-count">0</span> / 100KB
            <div class="char-bar">
                <div class="char-fill" id="char-fill"></div>
            </div>
        </div>
        
        <div class="input-actions">
            <button class="btn-icon" onclick="attachFile()" title="上传文件">
                📎
            </button>
            <button class="btn-primary" onclick="sendMessage()">
                发送
            </button>
        </div>
    </div>
</div>

<style>
.input-container {
    position: relative;
}

.input-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: rgba(0,0,0,0.02);
    border-top: 1px solid #e0e0e0;
}

.char-counter {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: #666;
}

.char-bar {
    width: 100px;
    height: 4px;
    background: #e0e0e0;
    border-radius: 2px;
    overflow: hidden;
}

.char-fill {
    height: 100%;
    background: #4CAF50;
    transition: width 0.3s, background 0.3s;
}

.char-fill.warning {
    background: #FF9800;
}

.char-fill.danger {
    background: #F44336;
}
</style>
```

---

### 2. 实时验证逻辑

```javascript
// 常量定义
const MAX_INPUT_LENGTH = 100 * 1024; // 100KB
const WARNING_THRESHOLD = 0.7;       // 70%警告
const DANGER_THRESHOLD = 0.9;        // 90%危险

// 输入监听
const userInput = document.getElementById('user-input');

userInput.addEventListener('input', function(e) {
    const currentLength = this.value.length;
    const percentage = currentLength / MAX_INPUT_LENGTH;
    
    // 更新计数显示
    updateCharCounter(currentLength, percentage);
    
    // 超过限制：截断
    if (currentLength > MAX_INPUT_LENGTH) {
        this.value = this.value.substring(0, MAX_INPUT_LENGTH);
        showOverLimitWarning();
    }
});

function updateCharCounter(length, percentage) {
    const kb = (length / 1024).toFixed(1);
    const fill = document.getElementById('char-fill');
    const counter = document.getElementById('char-counter');
    
    // 更新文字
    counter.querySelector('.char-count').textContent = kb + 'KB';
    
    // 更新进度条
    fill.style.width = (percentage * 100) + '%';
    
    // 颜色警告
    if (percentage >= DANGER_THRESHOLD) {
        fill.className = 'char-fill danger';
        counter.style.color = '#F44336';
    } else if (percentage >= WARNING_THRESHOLD) {
        fill.className = 'char-fill warning';
        counter.style.color = '#FF9800';
    } else {
        fill.className = 'char-fill';
        counter.style.color = '#666';
    }
}
```

---

### 3. 发送前验证

```javascript
function sendMessage() {
    const message = userInput.value.trim();
    const length = message.length;
    const lengthKB = (length / 1024).toFixed(1);
    
    // 空内容检查
    if (length === 0) {
        showToast('⚠️ 请输入内容', 'warning');
        return;
    }
    
    // 长度检查
    if (length > MAX_INPUT_LENGTH) {
        showLargeInputDialog(lengthKB);
        return;
    }
    
    // 警告阈值（70KB以上）
    if (length > MAX_INPUT_LENGTH * 0.7) {
        showLargeInputConfirmation(lengthKB, message);
        return;
    }
    
    // 正常发送
    actualSend(message);
}
```

---

### 4. 超长输入引导对话框

```javascript
function showLargeInputDialog(lengthKB) {
    const dialog = `
        <div class="modal-overlay" id="large-input-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>📋 输入内容过长</h3>
                    <button onclick="closeModal('large-input-modal')">✕</button>
                </div>
                
                <div class="modal-body">
                    <div class="alert alert-warning">
                        您的输入有 <strong>${lengthKB}KB</strong>，超过100KB限制。
                    </div>
                    
                    <p>为了更好的体验和性能，建议使用以下方式：</p>
                    
                    <div class="guide-options">
                        <div class="guide-option" onclick="selectGuideOption(1)">
                            <div class="option-icon">📁</div>
                            <div class="option-content">
                                <h4>方式1：保存为文件（推荐）</h4>
                                <p>将内容保存到项目 <code>temp/</code> 目录</p>
                                <code class="example">
                                    然后输入："帮我分析 temp/my_data.txt"
                                </code>
                            </div>
                        </div>
                        
                        <div class="guide-option" onclick="selectGuideOption(2)">
                            <div class="option-icon">✂️</div>
                            <div class="option-content">
                                <h4>方式2：拆分提问</h4>
                                <p>将大段内容分成几个小问题</p>
                                <code class="example">
                                    逐步提问，Agent会记住上下文
                                </code>
                            </div>
                        </div>
                        
                        <div class="guide-option" onclick="selectGuideOption(3)">
                            <div class="option-icon">🔗</div>
                            <div class="option-content">
                                <h4>方式3：引用项目文件</h4>
                                <p>如果是项目代码，直接引用路径</p>
                                <code class="example">
                                    "分析 src/main.py 的性能问题"
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-footer">
                    <button class="btn-secondary" onclick="createTempFile()">
                        📝 帮我创建临时文件
                    </button>
                    <button class="btn-secondary" onclick="closeModal('large-input-modal')">
                        取消
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', dialog);
}

// 选择引导方式
function selectGuideOption(option) {
    switch(option) {
        case 1:
            // 方式1：创建临时文件
            createTempFileWithContent();
            break;
        case 2:
            // 方式2：引导拆分
            showSplitGuidance();
            break;
        case 3:
            // 方式3：显示文件引用示例
            showFileReferenceExamples();
            break;
    }
}

// 自动创建临时文件
function createTempFileWithContent() {
    const content = userInput.value;
    const timestamp = Date.now();
    const filename = `temp/input_${timestamp}.txt`;
    
    // 调用Agent创建文件
    const createCommand = {
        type: 'create_temp_file',
        filename: filename,
        content: content
    };
    
    agentBridge.createTempFile(JSON.stringify(createCommand));
    
    // 替换输入框内容为引用
    userInput.value = `帮我分析 ${filename} 文件的内容`;
    
    // 关闭对话框
    closeModal('large-input-modal');
    
    // 显示提示
    showToast(`✅ 已保存到 ${filename}`, 'success');
}
```

---

## 🎨 CSS样式

```css
.guide-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin: 16px 0;
}

.guide-option {
    display: flex;
    gap: 12px;
    padding: 16px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
}

.guide-option:hover {
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.05);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.option-icon {
    font-size: 32px;
    line-height: 1;
}

.option-content h4 {
    margin: 0 0 8px 0;
    color: #333;
}

.option-content p {
    margin: 0 0 8px 0;
    color: #666;
    font-size: 14px;
}

.option-content code.example {
    display: block;
    padding: 8px 12px;
    background: #f5f5f5;
    border-left: 3px solid #667eea;
    font-family: 'Consolas', monospace;
    font-size: 13px;
    color: #667eea;
}

.alert-warning {
    padding: 12px 16px;
    background: #fff3cd;
    border-left: 4px solid #ffc107;
    color: #856404;
    margin-bottom: 16px;
    border-radius: 4px;
}
```

---

## 🔧 后端支持

### Qt Bridge增加临时文件创建

```python
# main_qt.py

class AgentBridge(QObject):
    
    @pyqtSlot(str)
    def createTempFile(self, data: str):
        """创建临时文件（用于大文本输入）"""
        import json
        from pathlib import Path
        
        try:
            request = json.loads(data)
            filename = request.get("filename")
            content = request.get("content")
            
            # 确保temp目录存在
            temp_dir = Path(self.workspace_root) / "temp"
            temp_dir.mkdir(exist_ok=True)
            
            # 写入文件
            file_path = Path(self.workspace_root) / filename
            file_path.write_text(content, encoding='utf-8')
            
            print(f"[AgentBridge.createTempFile] ✅ 创建临时文件: {filename}")
            print(f"[AgentBridge.createTempFile] 文件大小: {len(content)/1024:.1f}KB")
            
            # 通知前端
            self._send_to_frontend({
                "type": "temp_file_created",
                "filename": filename,
                "size": len(content)
            })
            
        except Exception as e:
            print(f"[AgentBridge.createTempFile] ❌ 失败: {e}")
            self._send_to_frontend({
                "type": "error",
                "message": f"创建临时文件失败: {str(e)}"
            })
```

---

## 📊 不同长度的处理策略

### 智能分级处理

```javascript
const INPUT_STRATEGIES = {
    // 0-10KB: 正常处理
    NORMAL: {
        threshold: 10 * 1024,
        action: 'direct_send',
        message: null
    },
    
    // 10-50KB: 提示但允许
    LARGE: {
        threshold: 50 * 1024,
        action: 'warn_and_send',
        message: '输入较长，建议使用文件方式'
    },
    
    // 50-70KB: 建议文件
    VERY_LARGE: {
        threshold: 70 * 1024,
        action: 'suggest_file',
        message: '输入很长，强烈建议保存为文件'
    },
    
    // 70-100KB: 强烈警告
    EXTREMELY_LARGE: {
        threshold: 100 * 1024,
        action: 'strong_warning',
        message: '输入接近上限，建议使用文件方式'
    },
    
    // >100KB: 强制拒绝
    OVER_LIMIT: {
        threshold: Infinity,
        action: 'reject',
        message: '输入超过100KB限制，必须使用文件方式'
    }
};

function getInputStrategy(length) {
    if (length < INPUT_STRATEGIES.NORMAL.threshold) {
        return INPUT_STRATEGIES.NORMAL;
    } else if (length < INPUT_STRATEGIES.LARGE.threshold) {
        return INPUT_STRATEGIES.LARGE;
    } else if (length < INPUT_STRATEGIES.VERY_LARGE.threshold) {
        return INPUT_STRATEGIES.VERY_LARGE;
    } else if (length < INPUT_STRATEGIES.EXTREMELY_LARGE.threshold) {
        return INPUT_STRATEGIES.EXTREMELY_LARGE;
    } else {
        return INPUT_STRATEGIES.OVER_LIMIT;
    }
}

function sendMessage() {
    const message = userInput.value.trim();
    const length = message.length;
    const strategy = getInputStrategy(length);
    
    switch(strategy.action) {
        case 'direct_send':
            actualSend(message);
            break;
            
        case 'warn_and_send':
            showToast(`💡 ${strategy.message}`, 'info');
            actualSend(message);
            break;
            
        case 'suggest_file':
            showSuggestFileDialog(message, strategy.message);
            break;
            
        case 'strong_warning':
            showStrongWarningDialog(message, strategy.message);
            break;
            
        case 'reject':
            showOverLimitDialog(length);
            break;
    }
}
```

---

## 💡 智能建议：自动保存

### 一键保存功能

```javascript
function showSuggestFileDialog(message, warningMsg) {
    const lengthKB = (message.length / 1024).toFixed(1);
    
    const dialog = `
        <div class="modal-overlay">
            <div class="modal-content suggest-file-modal">
                <h3>💡 建议使用文件方式</h3>
                <p>${warningMsg}（当前${lengthKB}KB）</p>
                
                <div class="quick-actions">
                    <button class="action-card" onclick="autoSaveAndReference()">
                        <div class="card-icon">✨</div>
                        <div class="card-title">自动处理</div>
                        <div class="card-desc">
                            自动保存为临时文件并转换为引用
                        </div>
                    </button>
                    
                    <button class="action-card" onclick="manualSave()">
                        <div class="card-icon">💾</div>
                        <div class="card-title">手动保存</div>
                        <div class="card-desc">
                            我来手动保存文件
                        </div>
                    </button>
                    
                    <button class="action-card" onclick="sendAnyway()">
                        <div class="card-icon">⚡</div>
                        <div class="card-title">仍然发送</div>
                        <div class="card-desc">
                            继续发送（可能影响性能）
                        </div>
                    </button>
                </div>
            </div>
        </div>
    `;
    
    showModal(dialog);
}

function autoSaveAndReference() {
    const content = userInput.value;
    const timestamp = new Date().getTime();
    const filename = `temp/input_${timestamp}.txt`;
    
    // 1. 调用后端创建文件
    agentBridge.createTempFile(JSON.stringify({
        filename: filename,
        content: content
    }));
    
    // 2. 替换输入框为引用
    userInput.value = `请分析 ${filename} 文件的内容`;
    
    // 3. 关闭对话框
    closeAllModals();
    
    // 4. 提示用户
    showToast(`✅ 已保存到 ${filename}，可以继续补充说明`, 'success');
}
```

---

## 🎯 渐进式提示

### 根据长度动态提示

```javascript
// 实时提示（非阻塞）
function showLiveHints(length) {
    const hintBox = document.getElementById('input-hint');
    
    if (length > 70 * 1024) {
        hintBox.innerHTML = `
            ⚠️ 输入接近上限 (${(length/1024).toFixed(1)}KB/100KB)
            <button onclick="createTempFile()">保存为文件</button>
        `;
        hintBox.className = 'input-hint danger';
        hintBox.style.display = 'block';
    }
    else if (length > 50 * 1024) {
        hintBox.innerHTML = `
            💡 建议保存为文件 (${(length/1024).toFixed(1)}KB)
            <a href="#" onclick="showFileGuide()">查看教程</a>
        `;
        hintBox.className = 'input-hint warning';
        hintBox.style.display = 'block';
    }
    else {
        hintBox.style.display = 'none';
    }
}
```

---

## 📱 移动端适配

### 粘贴检测

```javascript
// 检测粘贴操作
userInput.addEventListener('paste', function(e) {
    // 获取粘贴内容
    const pasteData = e.clipboardData.getData('text');
    const pasteLength = pasteData.length;
    
    // 粘贴前预检
    if (pasteLength > MAX_INPUT_LENGTH) {
        e.preventDefault(); // 阻止粘贴
        
        const lengthKB = (pasteLength / 1024).toFixed(1);
        
        showConfirmDialog(
            '粘贴内容过长',
            `检测到您要粘贴 ${lengthKB}KB 的内容，超过100KB限制。\n\n` +
            `是否自动保存为临时文件？`,
            () => {
                // 用户确认：保存为文件
                savePasteAsFile(pasteData);
            },
            () => {
                // 取消：截断粘贴
                const truncated = pasteData.substring(0, MAX_INPUT_LENGTH);
                userInput.value += truncated;
                showToast('已截断到100KB', 'warning');
            }
        );
        
        return;
    }
    
    // 粘贴后会超限
    const currentLength = this.value.length;
    if (currentLength + pasteLength > MAX_INPUT_LENGTH) {
        e.preventDefault();
        
        // 计算可粘贴长度
        const available = MAX_INPUT_LENGTH - currentLength;
        const truncated = pasteData.substring(0, available);
        
        this.value += truncated;
        
        showToast(
            `⚠️ 内容已截断（超出限制 ${((pasteLength-available)/1024).toFixed(1)}KB）`,
            'warning'
        );
    }
});
```

---

## 🔒 后端验证（双重保险）

### API层验证

```python
# api/routes.py 或 main_qt.py

MAX_INPUT_LENGTH = 100 * 1024  # 100KB

@app.post("/agent/chat")
async def agent_chat(request: AgentRequest):
    """Agent对话接口"""
    
    message = request.message
    
    # 后端验证长度
    if len(message) > MAX_INPUT_LENGTH:
        raise HTTPException(
            status_code=400,
            detail=f"输入内容过长（{len(message)/1024:.1f}KB），超过100KB限制。请使用文件方式。"
        )
    
    # 正常处理
    ...
```

---

## 📊 用户教育

### 首次使用引导

```javascript
// 首次打开应用时显示
function showFirstTimeGuide() {
    if (localStorage.getItem('input_guide_shown')) {
        return; // 已显示过
    }
    
    const guide = `
        <div class="welcome-guide">
            <h2>💡 输入提示</h2>
            <ul>
                <li>✅ 输入框限制100KB（约5万字）</li>
                <li>✅ 大段文本建议保存为文件后分析</li>
                <li>✅ 可以随时上传文件 📎</li>
                <li>✅ 支持引用项目内任意文件</li>
            </ul>
            <button onclick="dismissGuide()">知道了</button>
        </div>
    `;
    
    showToast(guide, 'info', 10000);
    localStorage.setItem('input_guide_shown', 'true');
}
```

---

## 🎯 实施清单

### Day 1: 前端验证（核心）
- [ ] 添加maxlength属性
- [ ] 实现实时字符计数
- [ ] 添加颜色警告（安全/警告/危险）
- [ ] 发送前验证逻辑

### Day 2: 引导对话框
- [ ] 超长输入对话框UI
- [ ] 三种处理方式说明
- [ ] 自动保存临时文件功能
- [ ] 粘贴检测与处理

### Day 3: 后端集成
- [ ] Qt Bridge创建临时文件接口
- [ ] API层长度验证
- [ ] 错误提示优化

### Day 4: 用户体验
- [ ] 首次使用引导
- [ ] 示例与教程
- [ ] 测试各种场景

---

## 📈 效果预期

### 用户体验提升

| 指标 | 改进前 | 改进后 |
|------|--------|--------|
| 误粘贴大文件率 | 15% | <1% |
| 前端卡顿率 | 8% | <0.5% |
| Context爆炸率 | 12% | <2% |
| 用户困惑度 | 20% | <5% |

### 成本优化

```
假设每天10次误粘贴大文件：
  改进前：10次 × ¥0.5 = ¥5/天 = ¥150/月
  改进后：0次 × ¥0.5 = ¥0/月

节省：¥150/月 💰
```

---

## 💡 额外优化：智能压缩建议

### 输入分析与建议

```javascript
function analyzeInputAndSuggest(message) {
    const length = message.length;
    
    // 检测是否是代码
    const codePatterns = /```|function|class|def |import /g;
    const isCode = codePatterns.test(message);
    
    // 检测是否是日志
    const logPatterns = /\[\d{4}-\d{2}-\d{2}|\bINFO\b|\bERROR\b|\bDEBUG\b/g;
    const isLog = logPatterns.test(message);
    
    // 智能建议
    if (isCode && length > 20 * 1024) {
        return {
            suggestion: 'file',
            message: '检测到代码内容，建议保存为 .py/.js 文件后分析'
        };
    }
    
    if (isLog && length > 10 * 1024) {
        return {
            suggestion: 'file',
            message: '检测到日志内容，建议保存为 .log 文件后分析'
        };
    }
    
    return { suggestion: 'ok' };
}
```

---

## 🎯 总结

### 核心价值

1. ✅ **防止误操作**  
   100KB限制避免用户误粘贴大文件

2. ✅ **优化性能**  
   减少前端渲染压力和后端处理负担

3. ✅ **控制成本**  
   避免不必要的超大Context

4. ✅ **引导正确使用**  
   教育用户使用文件方式处理大文本

5. ✅ **提升体验**  
   清晰的提示和一键解决方案

### 实施优先级

- **前端验证**：P0（立即做）
- **引导对话框**：P1（本周做）
- **智能建议**：P2（下周做）

**投入1天，避免大量潜在问题，非常值得！** ✅

