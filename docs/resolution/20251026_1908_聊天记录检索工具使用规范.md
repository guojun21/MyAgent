# 聊天记录检索工具使用规范与滥用防护方案

> 创建时间：2025-10-26 19:08  
> 状态：待实施  
> 优先级：P1（避免成本浪费）  
> 实施周期：1天

---

## 📋 问题背景

### 工具介绍

**query_history** (聊天记录检索工具)
- 基于MiniMax的语义搜索
- 用于检索历史对话中的相关信息
- 成本：每次调用 ¥0.002-0.005

### 当前问题：滥用导致成本浪费

```
❌ 错误使用案例1：
用户："列出当前目录的文件"
LLM：调用 query_history(query="文件列表")
→ 错误！应该用 list_files

❌ 错误使用案例2：
用户："查看config.py的内容"
LLM：调用 query_history(query="config.py内容")
→ 错误！应该用 read_file

❌ 错误使用案例3：
用户："搜索代码中的login函数"
LLM：调用 query_history(query="login函数")
→ 错误！应该用 search_code

问题根源：
  - 工具描述不够精确
  - LLM误判使用场景
  - 缺乏明确的使用边界
```

---

## 🎯 正确使用场景（仅限这些！）

### ✅ 应该使用 query_history 的场景

#### 场景1：询问历史对话内容

```
用户："我之前让你修改了什么文件？"
用户："刚才我们讨论的那个Bug是什么？"
用户："你上次给我的建议是什么？"
用户："我第一个问题是什么？"

关键词：
  - "之前"、"刚才"、"上次"
  - "我们讨论过"、"你说过"
  - "历史记录"、"对话记录"
```

#### 场景2：回溯决策和讨论

```
用户："为什么我们当时选择用JWT而不是Session？"
用户："之前关于性能优化的讨论结果是什么？"
用户："我记得我们改过端口号，改成多少了？"

关键词：
  - "为什么当时"、"之前的决策"
  - "讨论结果"、"达成共识"
```

#### 场景3：查找历史操作记录

```
用户："找一下我们上次创建的那个用户服务类"
用户："之前修改过哪些配置文件？"
用户："你帮我做过哪些重构？"

关键词：
  - "之前做过"、"历史操作"
  - 明确要求"查找对话记录"
```

---

## ❌ 绝对不应该使用的场景

### 场景1：查看当前项目文件（用 list_files/read_file）

```
❌ 错误：
用户："查看src目录有什么文件"
LLM：query_history(query="src目录文件")

✅ 正确：
LLM：list_files(directory="src")
```

### 场景2：搜索代码内容（用 search_code）

```
❌ 错误：
用户："搜索代码里的login函数"
LLM：query_history(query="login函数代码")

✅ 正确：
LLM：search_code(query="def login|function login")
```

### 场景3：读取文件内容（用 read_file）

```
❌ 错误：
用户："config.py里写了什么？"
LLM：query_history(query="config.py内容")

✅ 正确：
LLM：read_file(path="config.py")
```

### 场景4：执行命令（用 run_terminal）

```
❌ 错误：
用户："运行一下测试"
LLM：query_history(query="测试命令")

✅ 正确：
LLM：run_terminal(command="pytest")
```

---

## 🔧 工具定义优化

### 当前可能的问题定义

```python
# ❌ 太宽泛，容易误用
{
    "name": "query_history",
    "description": "查询聊天记录",
    "parameters": {
        "query": {"type": "string", "description": "查询内容"}
    }
}
```

### ✅ 优化后的精确定义

```python
{
    "name": "query_history",
    "description": """检索历史对话记录中的信息（仅用于回顾过去的讨论）。

⚠️ 重要限制：
此工具仅用于检索"之前对话中讨论过的内容"，不能用于：
- 查看项目文件内容（应使用 read_file）
- 列出目录文件（应使用 list_files）
- 搜索代码（应使用 search_code）
- 查看当前状态（应使用对应的实时工具）

✅ 正确使用场景：
- 用户询问"之前/刚才/上次"的对话内容
- 回顾历史决策和讨论过程
- 查找"我们讨论过"的某个话题
- 追溯"你之前说过"的建议

如果用户问的是"当前/现在"的信息，不要使用此工具！""",
    
    "parameters": {
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "要检索的历史对话关键词或主题"
            },
            "time_range": {
                "type": "string",
                "enum": ["recent", "all"],
                "description": "检索范围：recent=最近5轮对话，all=全部历史"
            }
        },
        "required": ["query"]
    }
}
```

---

## 🎨 System Prompt增强

### 在Agent系统提示词中添加工具使用规则

```python
AGENT_SYSTEM_PROMPT = """你是一个智能编程助手Agent...

# 工具使用规则

## query_history（历史对话检索）
⚠️ 严格限制：仅在用户明确询问"历史对话"时使用！

正确场景：
  ✅ "我之前问了什么？"
  ✅ "你上次的建议是什么？"
  ✅ "我们讨论过XX吗？"

错误场景（禁止使用）：
  ❌ "查看config.py" → 应用 read_file
  ❌ "列出文件" → 应用 list_files
  ❌ "搜索代码" → 应用 search_code
  ❌ 任何关于"当前/现在"状态的查询

判断标准：
  - 用户提到"之前/刚才/上次/历史" → 可以用 query_history
  - 用户问"当前/现在/有什么" → 不能用 query_history

## 其他工具
- read_file: 读取文件内容（当前状态）
- list_files: 列出目录文件（当前状态）
- search_code: 搜索代码（当前状态）
- query_history: 检索对话（历史状态）

记住：历史 vs 当前，两类工具不能混用！
"""
```

---

## 🔍 使用前检测机制

### Agent层面的工具调用拦截

```python
# core/agent.py

class Agent:
    
    HISTORY_KEYWORDS = [
        "之前", "刚才", "上次", "以前",
        "历史", "过去", "曾经",
        "我们讨论", "你说过", "我问过"
    ]
    
    CURRENT_STATE_KEYWORDS = [
        "当前", "现在", "目前",
        "查看", "列出", "读取", "搜索"
    ]
    
    def validate_tool_call(
        self, 
        tool_name: str, 
        arguments: dict,
        user_message: str
    ) -> tuple[bool, str]:
        """
        验证工具调用是否合理
        
        Returns:
            (是否允许, 错误信息)
        """
        
        # 特殊检查：query_history
        if tool_name == "query_history":
            return self._validate_query_history(arguments, user_message)
        
        return True, ""
    
    def _validate_query_history(
        self, 
        arguments: dict,
        user_message: str
    ) -> tuple[bool, str]:
        """验证query_history调用是否合理"""
        
        # 检查用户消息中是否有历史相关关键词
        has_history_keyword = any(
            kw in user_message 
            for kw in self.HISTORY_KEYWORDS
        )
        
        # 检查是否明显是当前状态查询
        has_current_keyword = any(
            kw in user_message 
            for kw in self.CURRENT_STATE_KEYWORDS
        )
        
        # 判断
        if has_current_keyword and not has_history_keyword:
            return False, (
                f"检测到当前状态查询（'{user_message}'），"
                f"不应使用query_history。"
                f"建议使用：read_file/list_files/search_code"
            )
        
        if not has_history_keyword:
            # 没有明确的历史关键词，可能误用
            print(f"[Agent] ⚠️ query_history可能误用，用户消息无历史关键词")
            # 允许但记录警告
            return True, ""
        
        # 合理使用
        return True, ""
    
    async def _execute_tool_call(self, tool_call: Dict[str, Any], user_message: str):
        """执行工具调用（增加验证）"""
        
        function_name = tool_call["function"]["name"]
        arguments = json.loads(tool_call["function"]["arguments"])
        
        # ========== 验证工具调用合理性 ==========
        is_valid, error_msg = self.validate_tool_call(
            function_name,
            arguments,
            user_message
        )
        
        if not is_valid:
            print(f"[Agent] ❌ 工具调用被拦截: {error_msg}")
            
            # 返回错误，让LLM重新选择工具
            return {
                "success": False,
                "error": f"工具使用不当：{error_msg}",
                "suggestion": "请使用正确的工具"
            }
        
        # 正常执行
        result = self.tool_manager.execute_tool(function_name, arguments)
        return result
```

---

## 📊 使用场景判断树

```
用户消息分析
   ↓
包含"之前/刚才/上次/历史"？
   ↓          ↓
  是         否
   ↓          ↓
✅ 可用     继续判断
query_history    ↓
              询问对话内容 vs 询问系统状态？
                ↓              ↓
              对话内容       系统状态
                ↓              ↓
            ✅ 可用        ❌ 不可用
         query_history   (用其他工具)

示例：
"我们之前讨论过XX吗？" → 对话内容 → ✅
"之前创建了什么文件？" → 对话内容 → ✅
"现在有什么文件？" → 系统状态 → ❌ 用list_files
"查看文件内容" → 系统状态 → ❌ 用read_file
```

---

## 🔒 多层防护机制

### 第1层：Tool Description（工具描述）

```python
# 在工具描述中明确限制
{
    "name": "query_history",
    "description": """检索历史对话记录（仅限回顾过去的讨论）

🎯 适用场景（ONLY这些）：
1. 用户询问"之前/刚才/上次"的对话内容
   示例："我刚才问了什么？"
2. 回顾历史决策和讨论
   示例："为什么我们选择用JWT？"
3. 查找过去的操作记录
   示例："之前修改过哪些文件？"

🚫 禁止使用场景：
1. 查看当前文件/目录 → 用 read_file/list_files
2. 搜索代码内容 → 用 search_code
3. 获取系统信息 → 用 get_project_structure
4. 任何不涉及"回顾历史对话"的操作

⚠️ 关键判断：
- 用户问"之前/历史" → 用此工具 ✅
- 用户问"当前/现在" → 不用此工具 ❌

如果不确定，优先使用其他实时工具！""",
    "parameters": {...}
}
```

---

### 第2层：System Prompt（系统提示）

```python
# 在AGENT_SYSTEM_PROMPT中强调
"""
# 工具选择指南

query_history 是一个特殊工具，成本较高，使用时必须严格遵守：

1️⃣ 仅在用户明确询问"历史对话"时使用
   ✅ "我之前问过什么？"
   ✅ "刚才的讨论结果是？"
   ❌ "当前有什么文件？" → 用 list_files

2️⃣ 判断口诀：
   - 问"过去" → query_history
   - 问"现在" → 实时工具(read_file/list_files/search_code)

3️⃣ 如果不确定，默认使用实时工具
   宁可少用 query_history，不要滥用
"""
```

---

### 第3层：Runtime Validation（运行时验证）

```python
# core/agent.py

class QueryHistoryValidator:
    """query_history调用验证器"""
    
    # 历史查询的关键词（必须包含其一）
    HISTORY_INDICATORS = [
        "之前", "刚才", "上次", "以前", "曾经",
        "历史", "过去", "earlier", "before", "previous",
        "我们讨论", "你说过", "我问过", "你建议",
        "第一次", "最初", "开始时"
    ]
    
    # 当前状态查询的关键词（如果包含则禁用）
    CURRENT_STATE_INDICATORS = [
        "当前", "现在", "目前", "现有",
        "查看", "列出", "显示", "读取",
        "有什么", "是什么", "包含",
        "文件内容", "目录结构", "代码"
    ]
    
    # 明确要求历史的强指示词
    EXPLICIT_HISTORY_REQUESTS = [
        "历史记录", "对话记录", "聊天记录",
        "之前的对话", "过去的讨论",
        "conversation history", "chat history"
    ]
    
    def validate(self, user_message: str, query: str) -> tuple[bool, str, float]:
        """
        验证query_history调用是否合理
        
        Returns:
            (是否允许, 原因, 置信度)
        """
        
        msg_lower = user_message.lower()
        
        # 1. 明确要求历史记录 → 100%允许
        if any(exp in msg_lower for exp in self.EXPLICIT_HISTORY_REQUESTS):
            return True, "用户明确要求历史记录", 1.0
        
        # 2. 包含历史关键词？
        has_history = any(kw in user_message for kw in self.HISTORY_INDICATORS)
        
        # 3. 包含当前状态关键词？
        has_current = any(kw in user_message for kw in self.CURRENT_STATE_INDICATORS)
        
        # 4. 决策矩阵
        if has_history and not has_current:
            # 明确是历史查询
            return True, "包含历史关键词", 0.9
        
        elif has_current and not has_history:
            # 明确是当前状态查询
            return False, "用户询问当前状态，应使用实时工具(read_file/list_files/search_code)", 0.95
        
        elif has_history and has_current:
            # 两者都有，需要进一步判断
            # 优先级：历史关键词在前 → 历史查询
            history_pos = min(
                (user_message.find(kw) for kw in self.HISTORY_INDICATORS if kw in user_message),
                default=999
            )
            current_pos = min(
                (user_message.find(kw) for kw in self.CURRENT_STATE_INDICATORS if kw in user_message),
                default=999
            )
            
            if history_pos < current_pos:
                return True, "历史关键词优先", 0.7
            else:
                return False, "当前状态关键词优先，建议用实时工具", 0.8
        
        else:
            # 都没有 → 默认拒绝（宁缺勿滥）
            return False, "用户未明确询问历史，默认使用实时工具", 0.6


# 在Agent中使用
class Agent:
    def __init__(self):
        ...
        self.query_history_validator = QueryHistoryValidator()
    
    async def _execute_tool_call(self, tool_call, user_message):
        """执行工具（带验证）"""
        
        function_name = tool_call["function"]["name"]
        arguments = json.loads(tool_call["function"]["arguments"])
        
        # ========== query_history特殊验证 ==========
        if function_name == "query_history":
            is_valid, reason, confidence = self.query_history_validator.validate(
                user_message,
                arguments.get("query", "")
            )
            
            if not is_valid:
                print(f"[Agent] ❌ query_history调用被拦截")
                print(f"  原因: {reason}")
                print(f"  置信度: {confidence*100:.0f}%")
                
                # 返回错误，让LLM重新选择
                return {
                    "success": False,
                    "error": f"工具使用不当：{reason}",
                    "suggestion": "请使用 read_file、list_files 或 search_code 等实时工具"
                }
            
            else:
                print(f"[Agent] ✅ query_history调用合理")
                print(f"  原因: {reason}")
        
        # 正常执行
        return self.tool_manager.execute_tool(function_name, arguments)
```

---

## 📊 使用统计与监控

### 统计query_history的使用模式

```python
class QueryHistoryMonitor:
    """query_history使用监控"""
    
    def __init__(self):
        self.usage_stats = {
            "total_calls": 0,
            "valid_calls": 0,
            "invalid_calls": 0,
            "rejected_calls": 0
        }
    
    def record_call(self, user_message: str, is_valid: bool, was_rejected: bool):
        """记录调用"""
        self.usage_stats["total_calls"] += 1
        
        if was_rejected:
            self.usage_stats["rejected_calls"] += 1
        elif is_valid:
            self.usage_stats["valid_calls"] += 1
        else:
            self.usage_stats["invalid_calls"] += 1
    
    def get_abuse_rate(self) -> float:
        """计算滥用率"""
        total = self.usage_stats["total_calls"]
        if total == 0:
            return 0.0
        
        invalid = self.usage_stats["invalid_calls"] + self.usage_stats["rejected_calls"]
        return invalid / total
    
    def should_alert(self) -> bool:
        """是否应该告警"""
        # 滥用率超过30%
        return self.get_abuse_rate() > 0.3
```

---

## 🎨 前端用户提示

### 输入时智能提示

```javascript
// 检测用户输入意图
userInput.addEventListener('input', function() {
    const message = this.value;
    
    // 检测是否要查询历史
    const historyKeywords = ['之前', '刚才', '上次', '历史'];
    const hasHistoryIntent = historyKeywords.some(kw => message.includes(kw));
    
    // 检测是否要查询当前状态
    const currentKeywords = ['查看', '列出', '读取', '搜索'];
    const hasCurrentIntent = currentKeywords.some(kw => message.includes(kw));
    
    const hintBox = document.getElementById('input-hint');
    
    if (hasHistoryIntent && hasCurrentIntent) {
        // 意图混淆
        hintBox.innerHTML = `
            💡 提示：您的问题包含"历史"和"当前"两种查询，请明确：
            <br>• 询问对话历史 → "我们之前讨论过..."
            <br>• 查看当前状态 → "现在项目里有..."
        `;
        hintBox.className = 'input-hint warning';
    }
    else if (hasCurrentIntent) {
        hintBox.innerHTML = `
            💡 Agent会自动读取当前文件/目录，无需粘贴内容
        `;
        hintBox.className = 'input-hint info';
    }
    else {
        hintBox.style.display = 'none';
    }
});
```

---

## 🎯 Few-shot示例（教育LLM）

### 在首次对话时注入示例

```python
# 在系统初始化时添加到Context
FEW_SHOT_EXAMPLES = [
    {
        "role": "user",
        "content": "我之前问的第一个问题是什么？"
    },
    {
        "role": "assistant",
        "content": "我需要检索历史对话",
        "tool_calls": [{
            "function": {
                "name": "query_history",
                "arguments": '{"query": "第一个问题"}'
            }
        }]
    },
    {
        "role": "user",
        "content": "查看config.py的内容"
    },
    {
        "role": "assistant",
        "content": "我需要读取当前文件",
        "tool_calls": [{
            "function": {
                "name": "read_file",
                "arguments": '{"path": "config.py"}'
            }
        }]
    }
]
```

---

## 💰 成本影响分析

### 滥用的成本

```
假设场景：
  - 每天100次对话
  - 20%误用query_history（应该用免费工具）
  - 每次query_history成本：¥0.003

每天浪费：100 × 0.2 × 0.003 = ¥0.06
每月浪费：¥0.06 × 30 = ¥1.8
每年浪费：¥1.8 × 12 = ¥21.6

实施防护后：
  误用率：20% → 2%
  每年节省：¥21.6 × 0.9 = ¥19.44 💰
```

---

## 📈 监控与告警

### 定期检查滥用率

```python
# 每天自动检查
def daily_tool_usage_check():
    monitor = QueryHistoryMonitor()
    
    abuse_rate = monitor.get_abuse_rate()
    
    if abuse_rate > 0.3:
        # 发送告警
        alert = f"""
        ⚠️ query_history滥用率告警
        
        滥用率：{abuse_rate*100:.1f}%
        总调用：{monitor.usage_stats['total_calls']}次
        无效调用：{monitor.usage_stats['invalid_calls']}次
        被拦截：{monitor.usage_stats['rejected_calls']}次
        
        建议：
        1. 检查Tool Description是否够清晰
        2. 增强System Prompt约束
        3. 查看具体的误用case
        """
        
        send_admin_alert(alert)
```

---

## 🎯 实施清单

### Day 1: 工具定义优化
- [ ] 重写query_history的description
- [ ] 添加详细的使用/禁止场景说明
- [ ] 增加参数time_range限制

### Day 2: 验证机制
- [ ] 实现QueryHistoryValidator
- [ ] Agent层面拦截逻辑
- [ ] 错误提示优化

### Day 3: Prompt增强
- [ ] System Prompt添加工具使用规则
- [ ] Few-shot示例注入
- [ ] 测试LLM理解效果

### Day 4: 监控与优化
- [ ] 使用统计收集
- [ ] 滥用率计算
- [ ] 告警机制

---

## 📊 效果预期

| 指标 | 改进前 | 改进后 | 提升 |
|------|--------|--------|------|
| query_history滥用率 | 25% | <5% | ⬇️ 80% |
| 工具选择准确率 | 75% | >92% | ⬆️ 23% |
| 成本节省 | - | ¥19/年 | - |
| 用户体验 | 中 | 高 | ⬆️ |

---

## 💡 扩展：通用工具使用规范

### 建立完整的工具使用决策树

```
用户询问
   ↓
┌─────────────────────────────────────┐
│ 意图分类                             │
├─────────────────────────────────────┤
│ 1. 回顾历史？                        │
│    → query_history                  │
│                                     │
│ 2. 查看文件内容？                    │
│    → read_file                      │
│                                     │
│ 3. 列出文件？                        │
│    → list_files                     │
│                                     │
│ 4. 搜索代码？                        │
│    → search_code                    │
│                                     │
│ 5. 修改文件？                        │
│    → edit_file                      │
│                                     │
│ 6. 执行命令？                        │
│    → run_terminal                   │
│                                     │
│ 7. 项目结构？                        │
│    → get_project_structure          │
└─────────────────────────────────────┘
```

### 工具互斥规则

```python
TOOL_EXCLUSION_RULES = {
    "query_history": {
        "conflicts_with": ["read_file", "list_files", "search_code"],
        "reason": "历史查询 vs 当前状态查询",
        "decision": "优先使用实时工具"
    },
    "read_file": {
        "conflicts_with": ["query_history"],
        "when": "用户问当前文件内容"
    },
    "search_code": {
        "conflicts_with": ["query_history"],
        "when": "用户要搜索代码"
    }
}
```

---

## 🎯 总结

### 核心原则

**query_history 三原则**：
1. ✅ 只用于"回顾历史对话"
2. ✅ 如果不确定，不要用
3. ✅ 有其他工具能实现，优先用其他

### 判断口诀

```
用户问"过去" → query_history ✅
用户问"现在" → 实时工具 ✅
用户没明说 → 实时工具 ✅（宁缺勿滥）
```

### 防护机制

- 🛡️ **三层防护**：Description + System Prompt + Runtime Validation
- 🛡️ **成本控制**：减少80%滥用
- 🛡️ **用户引导**：前端智能提示

### 实施收益

- ✅ 节省成本：¥19/年
- ✅ 提升准确率：+23%
- ✅ 优化体验：减少误调用
- ✅ 系统健壮性：明确工具边界

**投入1天，建立清晰的工具使用规范，长期收益！** 💰✅

