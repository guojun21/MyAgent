# APIè°ƒç”¨å®Œæ•´æ—¥å¿—æ–¹æ¡ˆ

> åˆ›å»ºæ—¶é—´ï¼š2025-10-26 19:09  
> çŠ¶æ€ï¼šå¾…å®æ–½  
> ä¼˜å…ˆçº§ï¼šP2ï¼ˆè°ƒè¯•ä¸å®¡è®¡ï¼‰  
> å®æ–½å‘¨æœŸï¼š2å¤©

---

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

**å¿ å®è®°å½•æ¯æ¬¡LLM APIè°ƒç”¨çš„å®Œæ•´è¾“å…¥è¾“å‡ºï¼Œåˆ†æ–‡ä»¶å­˜å‚¨ï¼Œä¾¿äºè°ƒè¯•ã€å®¡è®¡å’Œåˆ†æ**

---

## ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ

### ä½¿ç”¨åœºæ™¯

1. **è°ƒè¯•å·¥å…·è°ƒç”¨é—®é¢˜**
   ```
   é—®é¢˜ï¼š"ä¸ºä»€ä¹ˆLLMè°ƒç”¨äº†é”™è¯¯çš„å·¥å…·ï¼Ÿ"
   â†’ æŸ¥çœ‹è¾“å…¥ï¼šçœ‹åˆ°åº•å‘äº†ä»€ä¹ˆmessages
   â†’ æŸ¥çœ‹è¾“å‡ºï¼šçœ‹LLMåˆ°åº•è¿”å›äº†ä»€ä¹ˆ
   â†’ å®šä½é—®é¢˜æ ¹æº
   ```

2. **å®¡è®¡ä¸åˆè§„**
   ```
   ä¼ä¸šéœ€æ±‚ï¼š
   - è®°å½•æ‰€æœ‰AIäº¤äº’
   - å®¡è®¡æ•æ„Ÿæ“ä½œ
   - è¿½è¸ªæˆæœ¬æ¶ˆè€—
   - æ³•è§„åˆè§„è¦æ±‚
   ```

3. **æ€§èƒ½åˆ†æ**
   ```
   åˆ†æï¼š
   - å“ªäº›promptå¯¼è‡´æ…¢å“åº”
   - å“ªäº›è°ƒç”¨æ¶ˆè€—tokenæœ€å¤š
   - é”™è¯¯ç‡ç»Ÿè®¡
   ```

4. **Promptä¼˜åŒ–**
   ```
   å¯¹æ¯”ï¼š
   - ä¸åŒpromptçš„æ•ˆæœ
   - A/Bæµ‹è¯•æ•°æ®æ”¯æŒ
   - æŒç»­ä¼˜åŒ–ä¾æ®
   ```

---

## ğŸ“ æ–‡ä»¶ç»„ç»‡ç»“æ„

### ç›®å½•è®¾è®¡

```
api_logs/
â”œâ”€â”€ 20251026/                      # æŒ‰æ—¥æœŸåˆ†ç»„
â”‚   â”œâ”€â”€ session_abc123/            # æŒ‰sessionåˆ†ç»„
â”‚   â”‚   â”œâ”€â”€ call_001/              # ç¬¬1æ¬¡APIè°ƒç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ metadata.json      # è°ƒç”¨è®°å½•ï¼ˆå…ƒæ•°æ®ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ input.json         # è¾“å…¥å†…å®¹
â”‚   â”‚   â”‚   â””â”€â”€ output.json        # è¾“å‡ºå†…å®¹
â”‚   â”‚   â”œâ”€â”€ call_002/              # ç¬¬2æ¬¡APIè°ƒç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ metadata.json
â”‚   â”‚   â”‚   â”œâ”€â”€ input.json
â”‚   â”‚   â”‚   â””â”€â”€ output.json
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ session_def456/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ summary.json               # å½“å¤©æ±‡æ€»
â”œâ”€â”€ 20251027/
â”‚   â””â”€â”€ ...
â””â”€â”€ index.json                     # æ€»ç´¢å¼•
```

---

## ğŸ“Š æ•°æ®ç»“æ„è®¾è®¡

### 1. metadata.jsonï¼ˆè°ƒç”¨è®°å½•ï¼‰

```json
{
    "call_id": "call_20251026_190512_001",
    "session_id": "abc123",
    "timestamp": 1729943112.345,
    "datetime": "2025-10-26 19:05:12",
    
    "api_info": {
        "provider": "deepseek",
        "model": "deepseek-chat",
        "base_url": "https://api.deepseek.com",
        "endpoint": "/v1/chat/completions"
    },
    
    "request_info": {
        "messages_count": 15,
        "tools_count": 11,
        "tool_choice": "auto",
        "temperature": 0.7,
        "has_tools": true
    },
    
    "response_info": {
        "id": "chatcmpl-xxx",
        "object": "chat.completion",
        "created": 1729943112,
        "finish_reason": "tool_calls",
        "has_tool_calls": true,
        "tool_calls_count": 2
    },
    
    "usage": {
        "prompt_tokens": 1296,
        "completion_tokens": 167,
        "total_tokens": 1463
    },
    
    "performance": {
        "latency_ms": 2345,
        "tokens_per_second": 71.2
    },
    
    "context": {
        "user_message": "å¸®æˆ‘ä¿®æ”¹UIé¢œè‰²",
        "agent_iteration": 3,
        "phase": "Phase 1",
        "round": 2
    },
    
    "files": {
        "input": "input.json",
        "output": "output.json"
    },
    
    "cost_estimate": {
        "input_cost": 0.001296,
        "output_cost": 0.000334,
        "total_cost": 0.00163,
        "currency": "CNY"
    }
}
```

---

### 2. input.jsonï¼ˆè¾“å…¥å†…å®¹ï¼‰

```json
{
    "model": "deepseek-chat",
    "messages": [
        {
            "role": "system",
            "content": "ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ç¼–ç¨‹åŠ©æ‰‹Agent..."
        },
        {
            "role": "user",
            "content": "å¸®æˆ‘ä¿®æ”¹UIé¢œè‰²ä¸ºç´«è‰²"
        },
        {
            "role": "assistant",
            "content": "å¥½çš„ï¼Œæˆ‘å…ˆæŸ¥çœ‹UIæ–‡ä»¶",
            "tool_calls": [...]
        },
        {
            "role": "tool",
            "tool_call_id": "call_xxx",
            "content": "{\"success\": true, ...}"
        }
    ],
    "tools": [
        {
            "type": "function",
            "function": {
                "name": "read_file",
                "description": "...",
                "parameters": {...}
            }
        },
        ...
    ],
    "tool_choice": "auto",
    "temperature": 0.7
}
```

---

### 3. output.jsonï¼ˆè¾“å‡ºå†…å®¹ï¼‰

```json
{
    "id": "chatcmpl-abc123",
    "object": "chat.completion",
    "created": 1729943112,
    "model": "deepseek-chat",
    "system_fingerprint": "fp_xxx",
    
    "choices": [
        {
            "index": 0,
            "finish_reason": "tool_calls",
            "message": {
                "role": "assistant",
                "content": null,
                "tool_calls": [
                    {
                        "id": "call_001",
                        "type": "function",
                        "function": {
                            "name": "edit_file",
                            "arguments": "{\"path\": \"ui/index.html\", ...}"
                        }
                    }
                ]
            }
        }
    ],
    
    "usage": {
        "prompt_tokens": 1296,
        "completion_tokens": 167,
        "total_tokens": 1463
    }
}
```

---

## ğŸ’» å®ç°ä»£ç 

### APIæ—¥å¿—è®°å½•å™¨

```python
# services/api_logger.py

import json
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional

class APILogger:
    """APIè°ƒç”¨æ—¥å¿—è®°å½•å™¨"""
    
    def __init__(self, log_root: str = "api_logs"):
        """
        åˆå§‹åŒ–APIæ—¥å¿—è®°å½•å™¨
        
        Args:
            log_root: æ—¥å¿—æ ¹ç›®å½•
        """
        self.log_root = Path(log_root)
        self.log_root.mkdir(exist_ok=True)
        
        self.current_session_id: Optional[str] = None
        self.call_counter = 0
    
    def set_session(self, session_id: str):
        """è®¾ç½®å½“å‰ä¼šè¯ID"""
        self.current_session_id = session_id
        self.call_counter = 0
    
    def log_api_call(
        self,
        request_data: Dict[str, Any],
        response_data: Dict[str, Any],
        context_info: Dict[str, Any]
    ) -> str:
        """
        è®°å½•ä¸€æ¬¡APIè°ƒç”¨
        
        Args:
            request_data: è¯·æ±‚æ•°æ®ï¼ˆmessages, toolsç­‰ï¼‰
            response_data: å“åº”æ•°æ®ï¼ˆå®Œæ•´responseï¼‰
            context_info: ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆsession, iterationç­‰ï¼‰
            
        Returns:
            æ—¥å¿—ç›®å½•è·¯å¾„
        """
        
        # ç”Ÿæˆcall_id
        self.call_counter += 1
        timestamp = datetime.now()
        call_id = f"call_{timestamp.strftime('%Y%m%d_%H%M%S')}_{self.call_counter:03d}"
        
        # åˆ›å»ºç›®å½•ç»“æ„
        date_dir = self.log_root / timestamp.strftime('%Y%m%d')
        session_dir = date_dir / f"session_{self.current_session_id or 'unknown'}"
        call_dir = session_dir / call_id
        
        call_dir.mkdir(parents=True, exist_ok=True)
        
        print(f"\n[APILogger] è®°å½•APIè°ƒç”¨: {call_id}")
        print(f"[APILogger] ç›®å½•: {call_dir}")
        
        # ========== 1. metadata.jsonï¼ˆè°ƒç”¨è®°å½•ï¼‰==========
        metadata = self._build_metadata(
            call_id,
            timestamp,
            request_data,
            response_data,
            context_info
        )
        
        metadata_file = call_dir / "metadata.json"
        metadata_file.write_text(
            json.dumps(metadata, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )
        
        # ========== 2. input.jsonï¼ˆè¾“å…¥å†…å®¹ï¼‰==========
        input_file = call_dir / "input.json"
        input_file.write_text(
            json.dumps(request_data, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )
        
        # ========== 3. output.jsonï¼ˆè¾“å‡ºå†…å®¹ï¼‰==========
        output_file = call_dir / "output.json"
        output_file.write_text(
            json.dumps(response_data, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )
        
        # ========== 4. å¯é€‰ï¼šinput.txtï¼ˆçº¯æ–‡æœ¬ç‰ˆï¼Œä¾¿äºé˜…è¯»ï¼‰==========
        input_txt = self._format_input_as_text(request_data)
        (call_dir / "input.txt").write_text(input_txt, encoding='utf-8')
        
        output_txt = self._format_output_as_text(response_data)
        (call_dir / "output.txt").write_text(output_txt, encoding='utf-8')
        
        print(f"[APILogger] âœ… æ—¥å¿—å·²ä¿å­˜")
        print(f"  - metadata.json: {metadata_file.stat().st_size} bytes")
        print(f"  - input.json: {input_file.stat().st_size} bytes")
        print(f"  - output.json: {output_file.stat().st_size} bytes")
        
        # æ›´æ–°ç´¢å¼•
        self._update_index(call_id, metadata)
        
        return str(call_dir)
    
    def _build_metadata(
        self,
        call_id: str,
        timestamp: datetime,
        request_data: Dict,
        response_data: Dict,
        context_info: Dict
    ) -> Dict:
        """æ„å»ºå…ƒæ•°æ®"""
        
        # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
        start_time = context_info.get("start_time", time.time())
        end_time = time.time()
        latency_ms = int((end_time - start_time) * 1000)
        
        # æå–usage
        usage = response_data.get("usage", {})
        total_tokens = usage.get("total_tokens", 0)
        completion_tokens = usage.get("completion_tokens", 0)
        
        tokens_per_second = 0
        if latency_ms > 0:
            tokens_per_second = (completion_tokens / latency_ms) * 1000
        
        # è®¡ç®—æˆæœ¬ï¼ˆDeepSeekä»·æ ¼ï¼‰
        prompt_tokens = usage.get("prompt_tokens", 0)
        input_cost = (prompt_tokens / 1000) * 0.001
        output_cost = (completion_tokens / 1000) * 0.002
        total_cost = input_cost + output_cost
        
        return {
            "call_id": call_id,
            "session_id": self.current_session_id,
            "timestamp": timestamp.timestamp(),
            "datetime": timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            
            "api_info": {
                "provider": context_info.get("provider", "deepseek"),
                "model": request_data.get("model", "unknown"),
                "base_url": context_info.get("base_url", ""),
                "endpoint": "/v1/chat/completions"
            },
            
            "request_info": {
                "messages_count": len(request_data.get("messages", [])),
                "tools_count": len(request_data.get("tools", [])) if request_data.get("tools") else 0,
                "tool_choice": request_data.get("tool_choice", "auto"),
                "temperature": request_data.get("temperature", 0.7),
                "has_tools": bool(request_data.get("tools"))
            },
            
            "response_info": {
                "id": response_data.get("id", ""),
                "object": response_data.get("object", ""),
                "created": response_data.get("created", 0),
                "finish_reason": response_data.get("choices", [{}])[0].get("finish_reason", ""),
                "has_tool_calls": bool(
                    response_data.get("choices", [{}])[0].get("message", {}).get("tool_calls")
                ),
                "tool_calls_count": len(
                    response_data.get("choices", [{}])[0].get("message", {}).get("tool_calls", [])
                )
            },
            
            "usage": usage,
            
            "performance": {
                "latency_ms": latency_ms,
                "tokens_per_second": round(tokens_per_second, 2)
            },
            
            "context": {
                "user_message": context_info.get("user_message", ""),
                "agent_iteration": context_info.get("iteration", 0),
                "phase": context_info.get("phase"),
                "round": context_info.get("round"),
                "task_id": context_info.get("task_id")
            },
            
            "files": {
                "input": "input.json",
                "output": "output.json",
                "input_txt": "input.txt",
                "output_txt": "output.txt"
            },
            
            "cost_estimate": {
                "input_cost": round(input_cost, 6),
                "output_cost": round(output_cost, 6),
                "total_cost": round(total_cost, 6),
                "currency": "CNY"
            }
        }
    
    def _format_input_as_text(self, request_data: Dict) -> str:
        """æ ¼å¼åŒ–è¾“å…¥ä¸ºå¯è¯»æ–‡æœ¬"""
        
        lines = []
        lines.append("=" * 80)
        lines.append("API REQUEST INPUT")
        lines.append("=" * 80)
        lines.append("")
        
        # Modelä¿¡æ¯
        lines.append(f"Model: {request_data.get('model', 'unknown')}")
        lines.append(f"Temperature: {request_data.get('temperature', 0.7)}")
        lines.append(f"Tool Choice: {request_data.get('tool_choice', 'auto')}")
        lines.append("")
        
        # Messages
        lines.append("â”€" * 80)
        lines.append("MESSAGES:")
        lines.append("â”€" * 80)
        
        for i, msg in enumerate(request_data.get("messages", []), 1):
            role = msg.get("role", "unknown").upper()
            content = msg.get("content", "")
            
            lines.append(f"\n[{i}] {role}:")
            lines.append("-" * 40)
            lines.append(content if content else "(empty)")
            
            if msg.get("tool_calls"):
                lines.append("\nTOOL CALLS:")
                for tc in msg["tool_calls"]:
                    lines.append(f"  - {tc['function']['name']}")
                    lines.append(f"    Args: {tc['function']['arguments']}")
        
        # Tools
        if request_data.get("tools"):
            lines.append("\n" + "â”€" * 80)
            lines.append("AVAILABLE TOOLS:")
            lines.append("â”€" * 80)
            
            for tool in request_data["tools"]:
                tool_name = tool["function"]["name"]
                tool_desc = tool["function"]["description"][:100]
                lines.append(f"\nâ€¢ {tool_name}")
                lines.append(f"  {tool_desc}...")
        
        lines.append("\n" + "=" * 80)
        
        return "\n".join(lines)
    
    def _format_output_as_text(self, response_data: Dict) -> str:
        """æ ¼å¼åŒ–è¾“å‡ºä¸ºå¯è¯»æ–‡æœ¬"""
        
        lines = []
        lines.append("=" * 80)
        lines.append("API RESPONSE OUTPUT")
        lines.append("=" * 80)
        lines.append("")
        
        # åŸºæœ¬ä¿¡æ¯
        lines.append(f"Response ID: {response_data.get('id', '')}")
        lines.append(f"Model: {response_data.get('model', '')}")
        lines.append(f"Finish Reason: {response_data.get('choices', [{}])[0].get('finish_reason', '')}")
        lines.append("")
        
        # Usage
        usage = response_data.get("usage", {})
        lines.append("USAGE:")
        lines.append(f"  Prompt Tokens: {usage.get('prompt_tokens', 0)}")
        lines.append(f"  Completion Tokens: {usage.get('completion_tokens', 0)}")
        lines.append(f"  Total Tokens: {usage.get('total_tokens', 0)}")
        lines.append("")
        
        # Messageå†…å®¹
        message = response_data.get("choices", [{}])[0].get("message", {})
        
        lines.append("â”€" * 80)
        lines.append("ASSISTANT MESSAGE:")
        lines.append("â”€" * 80)
        
        content = message.get("content")
        if content:
            lines.append(content)
        else:
            lines.append("(No text content)")
        
        # Tool Calls
        if message.get("tool_calls"):
            lines.append("\n" + "â”€" * 80)
            lines.append("TOOL CALLS:")
            lines.append("â”€" * 80)
            
            for i, tc in enumerate(message["tool_calls"], 1):
                lines.append(f"\n[{i}] {tc['function']['name']}")
                lines.append("-" * 40)
                
                # æ ¼å¼åŒ–å‚æ•°
                try:
                    args = json.loads(tc['function']['arguments'])
                    args_formatted = json.dumps(args, ensure_ascii=False, indent=2)
                    lines.append(args_formatted)
                except:
                    lines.append(tc['function']['arguments'])
        
        lines.append("\n" + "=" * 80)
        
        return "\n".join(lines)
    
    def _update_index(self, call_id: str, metadata: Dict):
        """æ›´æ–°æ€»ç´¢å¼•"""
        
        index_file = self.log_root / "index.json"
        
        # è¯»å–ç°æœ‰ç´¢å¼•
        if index_file.exists():
            index_data = json.loads(index_file.read_text(encoding='utf-8'))
        else:
            index_data = {"calls": [], "total_count": 0}
        
        # æ·»åŠ æ–°è®°å½•
        index_data["calls"].append({
            "call_id": call_id,
            "timestamp": metadata["timestamp"],
            "session_id": metadata["session_id"],
            "user_message": metadata["context"]["user_message"],
            "tokens": metadata["usage"]["total_tokens"],
            "cost": metadata["cost_estimate"]["total_cost"],
            "directory": str(Path(metadata["datetime"][:10]) / f"session_{metadata['session_id']}" / call_id)
        })
        
        index_data["total_count"] = len(index_data["calls"])
        
        # ä¿å­˜ç´¢å¼•
        index_file.write_text(
            json.dumps(index_data, ensure_ascii=False, indent=2),
            encoding='utf-8'
        )
```

---

## ğŸ”Œ é›†æˆåˆ°LLM Service

### DeepSeekæœåŠ¡æ”¹é€ 

```python
# services/llm_service.py

class DeepSeekService(LLMService):
    
    def __init__(self):
        ...
        # åˆå§‹åŒ–APIæ—¥å¿—è®°å½•å™¨
        from services.api_logger import APILogger
        self.api_logger = APILogger()
        self.enable_api_logging = True  # å¯é…ç½®å¼€å…³
    
    def chat(
        self, 
        messages: List[Dict[str, str]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        tool_choice: Union[str, Dict] = "auto",
        context_info: Optional[Dict] = None  # æ–°å¢ï¼šä¸Šä¸‹æ–‡ä¿¡æ¯
    ) -> Dict[str, Any]:
        """ä¸DeepSeekå¯¹è¯ï¼ˆæ”¯æŒFunction Calling + APIæ—¥å¿—ï¼‰"""
        
        # è®°å½•å¼€å§‹æ—¶é—´
        start_time = time.time()
        
        # æ„å»ºè¯·æ±‚æ•°æ®
        kwargs = {
            "model": self.model,
            "messages": messages,
            "temperature": 0.7,
        }
        
        if tools:
            kwargs["tools"] = tools
            kwargs["tool_choice"] = tool_choice
        
        # ========== è°ƒç”¨API ==========
        try:
            response = self.client.chat.completions.create(**kwargs)
            
            # ========== è®°å½•APIæ—¥å¿— ==========
            if self.enable_api_logging:
                try:
                    # å‡†å¤‡è®°å½•æ•°æ®
                    request_data = kwargs.copy()
                    response_data = response.model_dump()  # è½¬ä¸ºdict
                    
                    # è¡¥å……ä¸Šä¸‹æ–‡ä¿¡æ¯
                    full_context = {
                        "start_time": start_time,
                        "provider": "deepseek",
                        "base_url": settings.deepseek_base_url,
                        **(context_info or {})
                    }
                    
                    # è®°å½•æ—¥å¿—
                    self.api_logger.log_api_call(
                        request_data,
                        response_data,
                        full_context
                    )
                
                except Exception as log_error:
                    print(f"[DeepSeek] âš ï¸ APIæ—¥å¿—è®°å½•å¤±è´¥: {log_error}")
                    # æ—¥å¿—å¤±è´¥ä¸å½±å“ä¸»æµç¨‹
            
            # æ­£å¸¸å¤„ç†å“åº”
            message = response.choices[0].message
            ...
            
        except Exception as e:
            ...
```

---

## ğŸ”§ Agentå±‚é¢é›†æˆ

### ä¼ é€’ä¸Šä¸‹æ–‡ä¿¡æ¯

```python
# core/agent.py

class Agent:
    
    async def run(self, user_message, context_history):
        ...
        
        # è®¾ç½®session
        self.llm_service.api_logger.set_session(session_id)
        
        while iterations < self.max_iterations:
            iterations += 1
            
            # å‡†å¤‡ä¸Šä¸‹æ–‡ä¿¡æ¯
            context_info = {
                "user_message": user_message,
                "iteration": iterations,
                "phase": current_phase.name if current_phase else None,
                "round": current_round,
                "task_id": current_task.id if current_task else None
            }
            
            # è°ƒç”¨LLMï¼ˆä¼ é€’ä¸Šä¸‹æ–‡ï¼‰
            llm_response = self.llm_service.chat(
                messages=messages,
                tools=tools,
                tool_choice=tool_choice,
                context_info=context_info  # â† ä¼ é€’ä¸Šä¸‹æ–‡
            )
            
            ...
```

---

## ğŸ“Š æ—¥å¿—åˆ†æå·¥å…·

### ç»Ÿè®¡è„šæœ¬

```python
# tools/analyze_api_logs.py

import json
from pathlib import Path
from collections import defaultdict
from datetime import datetime

class APILogAnalyzer:
    """APIæ—¥å¿—åˆ†æå™¨"""
    
    def __init__(self, log_root: str = "api_logs"):
        self.log_root = Path(log_root)
    
    def analyze_date(self, date: str = None):
        """åˆ†ææŸå¤©çš„APIè°ƒç”¨"""
        
        if date is None:
            date = datetime.now().strftime('%Y%m%d')
        
        date_dir = self.log_root / date
        
        if not date_dir.exists():
            print(f"âŒ æ²¡æœ‰{date}çš„æ—¥å¿—")
            return
        
        stats = {
            "total_calls": 0,
            "total_tokens": 0,
            "total_cost": 0.0,
            "by_session": defaultdict(lambda: {"calls": 0, "tokens": 0, "cost": 0.0}),
            "by_tool": defaultdict(int),
            "by_finish_reason": defaultdict(int),
            "avg_latency": 0,
            "max_latency": 0
        }
        
        latencies = []
        
        # éå†æ‰€æœ‰call
        for call_dir in date_dir.rglob("call_*"):
            if not call_dir.is_dir():
                continue
            
            metadata_file = call_dir / "metadata.json"
            if not metadata_file.exists():
                continue
            
            metadata = json.loads(metadata_file.read_text(encoding='utf-8'))
            
            # ç»Ÿè®¡
            stats["total_calls"] += 1
            stats["total_tokens"] += metadata["usage"]["total_tokens"]
            stats["total_cost"] += metadata["cost_estimate"]["total_cost"]
            
            session = metadata["session_id"]
            stats["by_session"][session]["calls"] += 1
            stats["by_session"][session]["tokens"] += metadata["usage"]["total_tokens"]
            stats["by_session"][session]["cost"] += metadata["cost_estimate"]["total_cost"]
            
            stats["by_finish_reason"][metadata["response_info"]["finish_reason"]] += 1
            
            latencies.append(metadata["performance"]["latency_ms"])
            
            # å·¥å…·è°ƒç”¨ç»Ÿè®¡
            output_file = call_dir / "output.json"
            output = json.loads(output_file.read_text(encoding='utf-8'))
            tool_calls = output.get("choices", [{}])[0].get("message", {}).get("tool_calls", [])
            for tc in tool_calls:
                tool_name = tc["function"]["name"]
                stats["by_tool"][tool_name] += 1
        
        # è®¡ç®—å¹³å‡å€¼
        if latencies:
            stats["avg_latency"] = sum(latencies) / len(latencies)
            stats["max_latency"] = max(latencies)
        
        # æ‰“å°æŠ¥å‘Š
        self._print_report(date, stats)
        
        return stats
    
    def _print_report(self, date: str, stats: Dict):
        """æ‰“å°åˆ†ææŠ¥å‘Š"""
        
        print(f"\n{'='*80}")
        print(f"APIè°ƒç”¨åˆ†ææŠ¥å‘Š - {date}")
        print(f"{'='*80}\n")
        
        print(f"ğŸ“Š æ€»ä½“ç»Ÿè®¡:")
        print(f"  æ€»è°ƒç”¨æ¬¡æ•°: {stats['total_calls']}")
        print(f"  æ€»Tokenæ¶ˆè€—: {stats['total_tokens']:,}")
        print(f"  æ€»æˆæœ¬: Â¥{stats['total_cost']:.4f}")
        print(f"  å¹³å‡å»¶è¿Ÿ: {stats['avg_latency']:.0f}ms")
        print(f"  æœ€å¤§å»¶è¿Ÿ: {stats['max_latency']:.0f}ms")
        print("")
        
        print(f"ğŸ”§ å·¥å…·è°ƒç”¨ç»Ÿè®¡:")
        for tool, count in sorted(stats["by_tool"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {tool}: {count}æ¬¡")
        print("")
        
        print(f"ğŸ“ ç»“æŸåŸå› :")
        for reason, count in stats["by_finish_reason"].items():
            print(f"  {reason}: {count}æ¬¡")
        print("")
        
        print(f"ğŸ’¬ æŒ‰Sessionç»Ÿè®¡:")
        for session, data in list(stats["by_session"].items())[:5]:
            print(f"  {session[:8]}...")
            print(f"    è°ƒç”¨: {data['calls']}æ¬¡")
            print(f"    Token: {data['tokens']:,}")
            print(f"    æˆæœ¬: Â¥{data['cost']:.4f}")
        
        print(f"\n{'='*80}\n")
```

---

## ğŸ” æ—¥å¿—æŸ¥çœ‹å·¥å…·

### å¿«é€ŸæŸ¥çœ‹æœ€è¿‘çš„APIè°ƒç”¨

```python
# tools/view_api_log.py

def view_latest_call():
    """æŸ¥çœ‹æœ€æ–°çš„APIè°ƒç”¨"""
    
    log_root = Path("api_logs")
    
    # æ‰¾åˆ°æœ€æ–°çš„callç›®å½•
    all_calls = list(log_root.rglob("call_*"))
    if not all_calls:
        print("æ²¡æœ‰APIæ—¥å¿—")
        return
    
    latest_call = max(all_calls, key=lambda p: p.stat().st_mtime)
    
    print(f"\n{'='*80}")
    print(f"æœ€æ–°APIè°ƒç”¨: {latest_call.name}")
    print(f"{'='*80}\n")
    
    # è¯»å–metadata
    metadata = json.loads((latest_call / "metadata.json").read_text(encoding='utf-8'))
    
    print(f"æ—¶é—´: {metadata['datetime']}")
    print(f"ç”¨æˆ·æ¶ˆæ¯: {metadata['context']['user_message']}")
    print(f"Tokens: {metadata['usage']['total_tokens']}")
    print(f"æˆæœ¬: Â¥{metadata['cost_estimate']['total_cost']:.6f}")
    print(f"å»¶è¿Ÿ: {metadata['performance']['latency_ms']}ms")
    print("")
    
    # æ˜¾ç¤ºè¾“å…¥ï¼ˆå¯è¯»ç‰ˆï¼‰
    input_txt = (latest_call / "input.txt").read_text(encoding='utf-8')
    print("INPUT:")
    print("â”€" * 80)
    print(input_txt[:500])
    print("...(æŸ¥çœ‹å®Œæ•´å†…å®¹è¯·æ‰“å¼€ input.txt)")
    print("")
    
    # æ˜¾ç¤ºè¾“å‡º
    output_txt = (latest_call / "output.txt").read_text(encoding='utf-8')
    print("OUTPUT:")
    print("â”€" * 80)
    print(output_txt[:500])
    print("...(æŸ¥çœ‹å®Œæ•´å†…å®¹è¯·æ‰“å¼€ output.txt)")
    print("")
    
    print(f"å®Œæ•´æ—¥å¿—ç›®å½•: {latest_call}")
    print(f"{'='*80}\n")


def search_calls(keyword: str, date: str = None):
    """æœç´¢åŒ…å«å…³é”®è¯çš„APIè°ƒç”¨"""
    
    log_root = Path("api_logs")
    
    if date:
        search_root = log_root / date
    else:
        search_root = log_root
    
    results = []
    
    for call_dir in search_root.rglob("call_*"):
        metadata_file = call_dir / "metadata.json"
        if not metadata_file.exists():
            continue
        
        metadata = json.loads(metadata_file.read_text(encoding='utf-8'))
        
        # åœ¨user_messageä¸­æœç´¢
        if keyword.lower() in metadata["context"]["user_message"].lower():
            results.append({
                "call_id": metadata["call_id"],
                "datetime": metadata["datetime"],
                "user_message": metadata["context"]["user_message"],
                "tokens": metadata["usage"]["total_tokens"],
                "directory": call_dir
            })
    
    print(f"\næ‰¾åˆ° {len(results)} æ¡åŒ¹é…'{keyword}'çš„APIè°ƒç”¨:\n")
    
    for r in results[:10]:
        print(f"[{r['datetime']}] {r['user_message'][:50]}...")
        print(f"  Tokens: {r['tokens']}, ç›®å½•: {r['directory']}")
        print("")
```

---

## ğŸ¨ å‰ç«¯é›†æˆï¼ˆå¯é€‰ï¼‰

### APIæ—¥å¿—æŸ¥çœ‹é¢æ¿

```html
<div class="api-log-viewer">
    <h3>ğŸ” APIè°ƒç”¨æ—¥å¿—</h3>
    
    <div class="log-filters">
        <input type="date" id="log-date" />
        <input type="text" placeholder="æœç´¢å…³é”®è¯..." id="log-search" />
        <button onclick="loadAPILogs()">æŸ¥è¯¢</button>
    </div>
    
    <div class="log-list" id="api-log-list">
        <!-- æ—¥å¿—åˆ—è¡¨ -->
    </div>
</div>

<script>
function loadAPILogs() {
    const date = document.getElementById('log-date').value;
    const keyword = document.getElementById('log-search').value;
    
    // è°ƒç”¨åç«¯æŸ¥è¯¢
    agentBridge.queryAPILogs(date, keyword);
}

// æ˜¾ç¤ºæ—¥å¿—è¯¦æƒ…
function showLogDetail(callId) {
    agentBridge.getAPILogDetail(callId);
}
</script>
```

---

## âš™ï¸ é…ç½®é€‰é¡¹

### å¯é…ç½®çš„å¼€å…³

```python
# config.py

class Settings:
    ...
    
    # APIæ—¥å¿—é…ç½®
    enable_api_logging: bool = True          # æ˜¯å¦å¯ç”¨
    api_log_root: str = "api_logs"          # æ—¥å¿—æ ¹ç›®å½•
    api_log_keep_days: int = 30              # ä¿ç•™å¤©æ•°
    api_log_save_txt: bool = True            # æ˜¯å¦ä¿å­˜txtç‰ˆæœ¬
    api_log_compress_old: bool = True        # æ˜¯å¦å‹ç¼©æ—§æ—¥å¿—
```

---

## ğŸ—‚ï¸ æ—¥å¿—æ¸…ç†ä¸å½’æ¡£

### è‡ªåŠ¨æ¸…ç†æ—§æ—¥å¿—

```python
def cleanup_old_logs(keep_days: int = 30):
    """æ¸…ç†è¶…è¿‡Nå¤©çš„APIæ—¥å¿—"""
    
    log_root = Path("api_logs")
    cutoff_date = datetime.now() - timedelta(days=keep_days)
    cutoff_str = cutoff_date.strftime('%Y%m%d')
    
    deleted_count = 0
    saved_space = 0
    
    for date_dir in log_root.iterdir():
        if not date_dir.is_dir():
            continue
        
        # æ£€æŸ¥æ—¥æœŸ
        if date_dir.name < cutoff_str:
            # è®¡ç®—å¤§å°
            size = sum(f.stat().st_size for f in date_dir.rglob('*') if f.is_file())
            
            # åˆ é™¤
            shutil.rmtree(date_dir)
            
            deleted_count += 1
            saved_space += size
    
    print(f"âœ… æ¸…ç†å®Œæˆ")
    print(f"  åˆ é™¤æ—¥æœŸ: {deleted_count}å¤©")
    print(f"  é‡Šæ”¾ç©ºé—´: {saved_space / 1024 / 1024:.2f}MB")
```

### å‹ç¼©å½’æ¡£

```python
def archive_old_logs(archive_days: int = 7):
    """å‹ç¼©7å¤©å‰çš„æ—¥å¿—"""
    
    import zipfile
    
    log_root = Path("api_logs")
    archive_root = log_root / "archives"
    archive_root.mkdir(exist_ok=True)
    
    cutoff_date = datetime.now() - timedelta(days=archive_days)
    cutoff_str = cutoff_date.strftime('%Y%m%d')
    
    for date_dir in log_root.iterdir():
        if not date_dir.is_dir() or date_dir.name == "archives":
            continue
        
        if date_dir.name < cutoff_str:
            # å‹ç¼©
            zip_file = archive_root / f"{date_dir.name}.zip"
            
            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as zf:
                for file in date_dir.rglob('*'):
                    if file.is_file():
                        zf.write(file, file.relative_to(date_dir))
            
            # åˆ é™¤åŸç›®å½•
            shutil.rmtree(date_dir)
            
            print(f"âœ… å·²å½’æ¡£: {date_dir.name} â†’ {zip_file.name}")
```

---

## ğŸ¯ å®æ–½æ¸…å•

### Day 1: æ ¸å¿ƒåŠŸèƒ½
- [ ] å®ç°APILoggerç±»
- [ ] æ–‡ä»¶ç»„ç»‡ç»“æ„
- [ ] metadata/input/outputä¸‰æ–‡ä»¶ç”Ÿæˆ
- [ ] é›†æˆåˆ°DeepSeekService

### Day 2: åˆ†æå·¥å…·
- [ ] APILogAnalyzerç»Ÿè®¡åˆ†æ
- [ ] æŸ¥çœ‹æœ€æ–°æ—¥å¿—å·¥å…·
- [ ] æœç´¢æ—¥å¿—å·¥å…·
- [ ] æ¸…ç†ä¸å½’æ¡£è„šæœ¬

### Day 3: ä¼˜åŒ–å®Œå–„ï¼ˆå¯é€‰ï¼‰
- [ ] å‰ç«¯æ—¥å¿—æŸ¥çœ‹ç•Œé¢
- [ ] é…ç½®é€‰é¡¹
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆå¼‚æ­¥å†™å…¥ï¼‰

---

## ğŸ“Š æ”¶ç›Šåˆ†æ

### è°ƒè¯•æ•ˆç‡æå‡

```
é—®é¢˜å®šä½æ—¶é—´ï¼š
  æ”¹è¿›å‰ï¼š30åˆ†é’Ÿï¼ˆç¿»consoleæ—¥å¿—ï¼ŒçŒœæµ‹é—®é¢˜ï¼‰
  æ”¹è¿›åï¼š5åˆ†é’Ÿï¼ˆç›´æ¥æŸ¥çœ‹input/outputï¼‰
  æå‡ï¼š83% ğŸš€
```

### æˆæœ¬ä¼˜åŒ–ä¾æ®

```
å‘ç°é—®é¢˜ï¼š
  - æŸäº›promptå¯¼è‡´tokenæ¶ˆè€—æ˜¯å¹³å‡çš„3å€
  - é€šè¿‡æ—¥å¿—åˆ†ææ‰¾åˆ°å¹¶ä¼˜åŒ–
  - æˆæœ¬é™ä½ï¼šÂ¥100/æœˆ â†’ Â¥70/æœˆ
```

### å®¡è®¡åˆè§„

```
ä¼ä¸šè¦æ±‚ï¼š
  âœ… æ‰€æœ‰AIäº¤äº’å¯è¿½æº¯
  âœ… ä¿ç•™30å¤©å®¡è®¡è®°å½•
  âœ… æˆæœ¬æ ¸ç®—æœ‰ä¾æ®
```

---

## ğŸ’¡ é¢å¤–åŠŸèƒ½

### 1. é‡æ”¾åŠŸèƒ½

```python
def replay_api_call(call_id: str):
    """é‡æ”¾æŸæ¬¡APIè°ƒç”¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰"""
    
    # è¯»å–input
    call_dir = find_call_dir(call_id)
    input_data = json.loads((call_dir / "input.json").read_text())
    
    # é‡æ–°è°ƒç”¨API
    response = llm.chat(**input_data)
    
    # å¯¹æ¯”ç»“æœ
    original_output = json.loads((call_dir / "output.json").read_text())
    
    compare_responses(original_output, response)
```

### 2. å¯¼å‡ºåŠŸèƒ½

```python
def export_session_logs(session_id: str, output_file: str):
    """å¯¼å‡ºæŸä¸ªsessionçš„æ‰€æœ‰APIæ—¥å¿—"""
    
    logs = collect_session_logs(session_id)
    
    # å¯¼å‡ºä¸ºExcel/CSV
    import pandas as pd
    df = pd.DataFrame(logs)
    df.to_excel(output_file, index=False)
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒä»·å€¼

1. âœ… **å®Œæ•´è®°å½•**  
   æ¯æ¬¡APIè°ƒç”¨çš„è¾“å…¥è¾“å‡ºå®Œæ•´ä¿å­˜

2. âœ… **æ˜“äºè°ƒè¯•**  
   å¿«é€Ÿå®šä½é—®é¢˜ï¼ŒæŸ¥çœ‹åŸå§‹æ•°æ®

3. âœ… **æˆæœ¬åˆ†æ**  
   è¯¦ç»†çš„tokenå’Œæˆæœ¬ç»Ÿè®¡

4. âœ… **å®¡è®¡åˆè§„**  
   æ»¡è¶³ä¼ä¸šå®¡è®¡è¦æ±‚

5. âœ… **æŒç»­ä¼˜åŒ–**  
   æ•°æ®é©±åŠ¨çš„promptä¼˜åŒ–

### å®æ–½ä¼˜å…ˆçº§

- **æ ¸å¿ƒåŠŸèƒ½**ï¼šP1ï¼ˆ2å¤©å®æ–½ï¼‰
- **åˆ†æå·¥å…·**ï¼šP2ï¼ˆå¯é€‰ï¼‰
- **å‰ç«¯ç•Œé¢**ï¼šP3ï¼ˆé”¦ä¸Šæ·»èŠ±ï¼‰

**æŠ•å…¥2å¤©ï¼Œè·å¾—å®Œæ•´çš„APIå¯è§‚æµ‹æ€§ï¼** ğŸ”âœ…

