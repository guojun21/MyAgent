# 托管模式：自主任务生成与执行方案

> 创建时间：2025-10-26 19:10  
> 状态：概念设计  
> 优先级：P2（创新探索）  
> 实施周期：1-2周  
> 风险等级：⚠️ 中高（需要严格安全控制）

---

## 🌟 核心理念

**让Agent自主识别当前工作模式，生成相关任务并自动执行，用户无需干预。**

### 典型场景

```
场景：用户正在让Agent写方案文档

19:00 用户："帮我写3个方案文档"
   ↓
19:30 Agent完成3个文档
   ↓
19:31 用户："开启托管模式，继续生成相关方案"
   ↓
【托管模式启动】
   ↓
19:35 Agent自主生成："API监控方案"
19:40 Agent自主生成："性能优化方案"
19:45 Agent自主生成："安全防护方案"
...（持续到用户设定的时间或任务数）
   ↓
07:00 用户醒来
   ↓
查看生成的50个方案，筛选出20个有价值的
   ↓
开始执行
```

---

## 🏗️ 系统架构

### 双Agent架构（关键创新）

```
┌─────────────────────────────────────────────────────────┐
│  托管Agent (Autonomous Agent)                           │
│  角色：管理者/规划者                                     │
│  能力：只能发送请求和评估，不能直接操作文件              │
├─────────────────────────────────────────────────────────┤
│  🔧 专属工具集：                                         │
│  1. send_request      - 向执行Agent发送任务请求          │
│  2. judge_result      - 评估执行Agent的结果质量          │
│  3. generate_tasks    - 生成新任务候选列表               │
│  4. adjust_strategy   - 调整任务生成策略                 │
│  5. review_batch      - 批量审查已完成任务               │
│  6. detect_pattern    - 重新分析工作模式                 │
│  7. pause_autonomous  - 暂停托管模式                     │
└─────────────────────────────────────────────────────────┘
   ↓ send_request
┌─────────────────────────────────────────────────────────┐
│  执行Agent (Execution Agent)                            │
│  角色：执行者/工作者                                     │
│  能力：文件操作、代码搜索、终端命令等全部实际操作         │
├─────────────────────────────────────────────────────────┤
│  🔧 工具集：                                            │
│  read_file, write_file, edit_file, list_files,         │
│  search_code, run_terminal, etc.                       │
└─────────────────────────────────────────────────────────┘
   ↓ 执行结果
┌─────────────────────────────────────────────────────────┐
│  结果存储与质量评估                                      │
│  - 保存所有生成的文件/结果                               │
│  - 质量评分和分类                                        │
│  - 用户审核队列                                         │
└─────────────────────────────────────────────────────────┘
```

### 架构优势

**为什么要分离两个Agent？**

1. **安全隔离**
   - 托管Agent只能"规划"，不能"执行"
   - 防止自主模式下的危险操作
   - 所有实际操作由执行Agent完成，可审计

2. **职责清晰**
   - 托管Agent：想任务、评质量、调策略
   - 执行Agent：干活、报告结果
   - 不会混乱

3. **并发执行**
   - 托管Agent生成下一批任务
   - 执行Agent执行当前批次
   - 流水线并行

---

### 三大核心模块

```
┌─────────────────────────────────────────┐
│ 1️⃣ 工作模式识别器                       │
│    Pattern Recognizer                   │
│    - 分析最近对话                        │
│    - 识别重复模式                        │
│    - 提取工作主题                        │
└─────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────┐
│ 2️⃣ 自主任务生成器                       │
│    Autonomous Task Generator            │
│    - 基于模式生成新任务                   │
│    - 评估任务相关性                      │
│    - 控制生成数量                        │
└─────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────┐
│ 3️⃣ 自动执行引擎                         │
│    Auto Execution Engine                │
│    - 批量执行任务                        │
│    - 结果质量评估                        │
│    - 安全边界控制                        │
└─────────────────────────────────────────┘
```

---

## 🔧 托管Agent专属工具详解

### 工具1: send_request（发送任务请求）

```python
{
    "name": "send_request",
    "description": "向执行Agent发送任务请求，执行Agent会实际执行文件操作等任务",
    "parameters": {
        "type": "object",
        "properties": {
            "request_title": {
                "type": "string",
                "description": "任务标题"
            },
            "request_content": {
                "type": "string",
                "description": "详细的任务描述，将作为用户消息发送给执行Agent"
            },
            "priority": {
                "type": "integer",
                "description": "优先级(1-10)，高优先级优先执行",
                "minimum": 1,
                "maximum": 10
            },
            "expected_output": {
                "type": "string",
                "description": "期望的输出类型（文件/报告/代码等）"
            },
            "metadata": {
                "type": "object",
                "description": "附加元数据（如预估耗时、相关任务等）"
            }
        },
        "required": ["request_title", "request_content"]
    }
}

# 示例调用
{
    "request_title": "编写API监控方案文档",
    "request_content": "请编写一个详细的API监控方案，包括：监控指标设计、实时告警机制、性能分析工具等内容，保存到 docs/about2Do/ 目录",
    "priority": 8,
    "expected_output": "markdown文档",
    "metadata": {
        "estimated_time": 120,
        "related_to": ["API日志方案", "性能优化方案"]
    }
}
```

**执行流程**：
```
托管Agent调用send_request
   ↓
任务进入执行队列
   ↓
执行Agent拿到任务
   ↓
执行Agent调用实际工具(write_file等)
   ↓
返回结果给托管Agent
```

---

### 工具2: judge_result（评估结果质量）

```python
{
    "name": "judge_result",
    "description": "评估执行Agent完成的任务质量，判断是否达标、是否需要重做",
    "parameters": {
        "type": "object",
        "properties": {
            "task_id": {
                "type": "string",
                "description": "要评估的任务ID"
            },
            "result_content": {
                "type": "string",
                "description": "任务执行结果内容"
            },
            "evaluation_criteria": {
                "type": "array",
                "items": {"type": "string"},
                "description": "评估标准列表"
            },
            "quality_score": {
                "type": "number",
                "description": "质量评分(0-10)",
                "minimum": 0,
                "maximum": 10
            },
            "pass": {
                "type": "boolean",
                "description": "是否通过质量检查"
            },
            "feedback": {
                "type": "string",
                "description": "改进建议（如果不通过）"
            },
            "needs_revision": {
                "type": "boolean",
                "description": "是否需要重新执行"
            }
        },
        "required": ["task_id", "quality_score", "pass"]
    }
}

# 示例调用
{
    "task_id": "task_047",
    "result_content": "...(方案文档内容)...",
    "evaluation_criteria": [
        "结构完整性",
        "技术可行性",
        "内容详实度",
        "创新性"
    ],
    "quality_score": 8.5,
    "pass": true,
    "feedback": "方案质量优秀，建议实施",
    "needs_revision": false
}
```

---

### 工具3: generate_tasks（生成任务候选）

```python
{
    "name": "generate_tasks",
    "description": "基于当前工作模式生成新的任务候选列表，不直接执行，只是生成候选",
    "parameters": {
        "type": "object",
        "properties": {
            "base_theme": {
                "type": "string",
                "description": "基础主题"
            },
            "generation_strategy": {
                "type": "string",
                "enum": ["direct_variants", "lateral_expansion", "deep_dive", "innovative"],
                "description": "生成策略：直接变体/横向扩展/深度挖掘/创新探索"
            },
            "count": {
                "type": "integer",
                "description": "生成数量",
                "minimum": 1,
                "maximum": 20
            },
            "avoid_topics": {
                "type": "array",
                "items": {"type": "string"},
                "description": "要避免的主题（已生成过的）"
            },
            "tasks": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "title": {"type": "string"},
                        "description": {"type": "string"},
                        "estimated_value": {"type": "number"},
                        "reasoning": {"type": "string"}
                    }
                },
                "description": "生成的任务列表"
            }
        },
        "required": ["base_theme", "tasks"]
    }
}
```

---

### 工具4: adjust_strategy（调整生成策略）

```python
{
    "name": "adjust_strategy",
    "description": "根据执行反馈调整任务生成策略，优化后续任务的质量和相关性",
    "parameters": {
        "type": "object",
        "properties": {
            "current_quality_trend": {
                "type": "string",
                "enum": ["improving", "stable", "declining"],
                "description": "当前质量趋势"
            },
            "adjustment_reason": {
                "type": "string",
                "description": "调整原因"
            },
            "new_strategy": {
                "type": "object",
                "properties": {
                    "focus_areas": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "新的聚焦领域"
                    },
                    "generation_rate": {
                        "type": "string",
                        "enum": ["slower", "normal", "faster"],
                        "description": "生成速度调整"
                    },
                    "quality_over_quantity": {
                        "type": "boolean",
                        "description": "是否优先质量而非数量"
                    }
                }
            }
        },
        "required": ["current_quality_trend", "new_strategy"]
    }
}

# 示例：质量下降时调整
{
    "current_quality_trend": "declining",
    "adjustment_reason": "最近5个任务质量评分从8.5降到6.2，出现重复和无价值内容",
    "new_strategy": {
        "focus_areas": ["深度技术方案", "创新性探索"],
        "generation_rate": "slower",  # 放慢速度，提高质量
        "quality_over_quantity": true
    }
}
```

---

### 工具5: review_batch（批量审查）

```python
{
    "name": "review_batch",
    "description": "批量审查最近完成的N个任务，识别模式和问题",
    "parameters": {
        "type": "object",
        "properties": {
            "batch_size": {
                "type": "integer",
                "description": "审查最近多少个任务",
                "minimum": 5,
                "maximum": 20
            },
            "review_summary": {
                "type": "object",
                "properties": {
                    "high_quality_count": {"type": "integer"},
                    "medium_quality_count": {"type": "integer"},
                    "low_quality_count": {"type": "integer"},
                    "duplicate_found": {"type": "boolean"},
                    "pattern_drift": {"type": "boolean"},
                    "recommendations": {
                        "type": "array",
                        "items": {"type": "string"}
                    }
                }
            }
        },
        "required": ["batch_size", "review_summary"]
    }
}

# 示例输出
{
    "batch_size": 10,
    "review_summary": {
        "high_quality_count": 7,
        "medium_quality_count": 2,
        "low_quality_count": 1,
        "duplicate_found": true,  # 发现重复
        "pattern_drift": false,   # 没有偏离主题
        "recommendations": [
            "质量整体良好，建议继续",
            "发现2个重复主题，建议增强去重",
            "可以尝试更创新的方向"
        ]
    }
}
```

---

### 工具6: detect_pattern（重新识别模式）

```python
{
    "name": "detect_pattern",
    "description": "重新分析当前的工作模式，适应任务演变",
    "parameters": {
        "type": "object",
        "properties": {
            "trigger_reason": {
                "type": "string",
                "description": "为什么要重新识别"
            },
            "new_pattern": {
                "type": "object",
                "properties": {
                    "pattern_type": {"type": "string"},
                    "主题": {"type": "string"},
                    "theme_evolution": {"type": "string"},
                    "confidence": {"type": "number"}
                }
            },
            "should_continue": {
                "type": "boolean",
                "description": "是否应该继续当前方向"
            }
        },
        "required": ["new_pattern", "should_continue"]
    }
}

# 使用场景：
# 执行了20个任务后，重新分析是否还在正确的方向上
```

---

### 工具7: pause_autonomous（暂停控制）

```python
{
    "name": "pause_autonomous",
    "description": "暂停托管模式，等待用户介入",
    "parameters": {
        "type": "object",
        "properties": {
            "reason": {
                "type": "string",
                "enum": [
                    "quality_declining",
                    "cost_threshold",
                    "need_user_input",
                    "pattern_unclear",
                    "safety_concern"
                ],
                "description": "暂停原因"
            },
            "message_to_user": {
                "type": "string",
                "description": "给用户的说明"
            },
            "current_progress": {
                "type": "object",
                "description": "当前进度摘要"
            },
            "resume_suggestion": {
                "type": "string",
                "description": "建议如何恢复"
            }
        },
        "required": ["reason", "message_to_user"]
    }
}

# 示例：质量下降时主动暂停
{
    "reason": "quality_declining",
    "message_to_user": "已完成30个任务，但最近5个质量持续下降(平均6.1分)，建议暂停并人工审查",
    "current_progress": {
        "completed": 30,
        "high_quality": 22,
        "needs_review": 8
    },
    "resume_suggestion": "审查后可调整生成策略并继续"
}
```

---

## 🔄 托管Agent完整执行流程

### 主循环

```python
# core/autonomous_agent.py

class AutonomousAgent:
    """托管Agent（只能规划和评估，不能直接操作）"""
    
    def __init__(self, execution_agent: Agent):
        """
        初始化托管Agent
        
        Args:
            execution_agent: 执行Agent实例（负责实际操作）
        """
        self.execution_agent = execution_agent
        self.llm_service = get_llm_service()  # 托管Agent有自己的LLM
        
        # 托管Agent的专属工具
        self.tools = self._register_autonomous_tools()
    
    def _register_autonomous_tools(self):
        """注册托管Agent专属工具"""
        return [
            self._build_send_request_tool(),
            self._build_judge_result_tool(),
            self._build_generate_tasks_tool(),
            self._build_adjust_strategy_tool(),
            self._build_review_batch_tool(),
            self._build_detect_pattern_tool(),
            self._build_pause_autonomous_tool()
        ]
    
    async def run_autonomous_loop(self, initial_pattern: Dict, config: Dict):
        """托管模式主循环"""
        
        messages = [
            {
                "role": "system",
                "content": AUTONOMOUS_AGENT_PROMPT  # 托管Agent专用Prompt
            },
            {
                "role": "user",
                "content": f"""你现在是托管管理者。

识别到的工作模式：
{json.dumps(initial_pattern, ensure_ascii=False, indent=2)}

你的任务：
1. 基于这个模式持续生成相关任务
2. 调用send_request发送给执行Agent
3. 用judge_result评估执行结果
4. 根据质量调整策略
5. 达到停止条件时自动结束

配置：
- 最多{config['max_tasks']}个任务
- 最多运行{config['max_hours']}小时
- 成本上限¥{config['max_cost']}

开始工作吧！"""
            }
        ]
        
        task_queue = []
        executed_count = 0
        
        # ========== 托管Agent的迭代循环 ==========
        while executed_count < config['max_tasks']:
            
            # 调用托管Agent（它会决定下一步做什么）
            response = self.llm_service.chat(
                messages=messages,
                tools=self.tools,
                tool_choice="auto"  # 让托管Agent自己决定
            )
            
            # 处理工具调用
            if response.get("tool_calls"):
                for tool_call in response["tool_calls"]:
                    tool_name = tool_call["function"]["name"]
                    arguments = json.loads(tool_call["function"]["arguments"])
                    
                    # ========== 处理不同工具 ==========
                    
                    if tool_name == "send_request":
                        # 发送任务给执行Agent
                        task_result = await self._handle_send_request(arguments)
                        executed_count += 1
                        
                        # 返回结果给托管Agent
                        messages.append({
                            "role": "tool",
                            "content": json.dumps(task_result, ensure_ascii=False)
                        })
                    
                    elif tool_name == "judge_result":
                        # 评估已完成的任务
                        # (托管Agent自己做评估判断)
                        judgment = arguments  # 托管Agent的判断
                        self._record_judgment(judgment)
                    
                    elif tool_name == "generate_tasks":
                        # 生成新任务候选
                        new_tasks = arguments["tasks"]
                        task_queue.extend(new_tasks)
                    
                    elif tool_name == "adjust_strategy":
                        # 调整策略
                        self._apply_strategy_adjustment(arguments)
                    
                    elif tool_name == "review_batch":
                        # 批量审查
                        review = arguments["review_summary"]
                        self._process_review(review)
                    
                    elif tool_name == "detect_pattern":
                        # 重新识别模式
                        new_pattern = arguments["new_pattern"]
                        if not arguments["should_continue"]:
                            print("[Autonomous] 模式识别建议停止")
                            break
                    
                    elif tool_name == "pause_autonomous":
                        # 托管Agent主动暂停
                        print(f"[Autonomous] 主动暂停: {arguments['reason']}")
                        return self._generate_pause_report(arguments)
            
            else:
                # 托管Agent返回纯文本（可能是总结）
                print(f"[Autonomous] Agent消息: {response.get('content')}")
        
        # 生成最终报告
        return self._generate_final_report()
    
    async def _handle_send_request(self, request: Dict) -> Dict:
        """处理send_request工具调用"""
        
        print(f"\n[Autonomous→Execution] 发送任务: {request['request_title']}")
        
        # 调用执行Agent
        execution_result = await self.execution_agent.run(
            user_message=request["request_content"],
            context_history=[]  # 独立Context
        )
        
        # 包装返回结果
        return {
            "task_title": request["request_title"],
            "success": execution_result.get("success", False),
            "result_summary": execution_result.get("message", "")[:200],
            "tokens_used": execution_result.get("token_usage", {}).get("total_tokens", 0),
            "estimated_cost": self._estimate_cost(execution_result)
        }
```

---

## 🎨 托管Agent的System Prompt

```python
AUTONOMOUS_AGENT_PROMPT = """你是托管模式的管理Agent，负责自主生成和管理任务。

你的角色：
- 你是管理者，不是执行者
- 你只能通过工具与执行Agent交互
- 你不能直接操作文件、代码等

你的工具：
1. send_request: 发送任务给执行Agent
2. judge_result: 评估执行结果质量
3. generate_tasks: 生成新任务候选
4. adjust_strategy: 调整生成策略
5. review_batch: 批量审查任务
6. detect_pattern: 重新识别工作模式
7. pause_autonomous: 主动暂停（遇到问题时）

工作流程：
1. 基于工作模式，调用generate_tasks生成5-10个候选任务
2. 选择高价值的任务，用send_request发送给执行Agent
3. 收到结果后，用judge_result评估质量
4. 每完成10个任务，用review_batch批量审查
5. 根据审查结果，用adjust_strategy调整策略
6. 如果质量持续下降或偏离主题，用detect_pattern重新识别
7. 遇到异常情况，用pause_autonomous暂停并通知用户

⚠️⚠️⚠️ 最重要的规则：强记忆用户方向 ⚠️⚠️⚠️

用户在托管模式启动前给你的【核心方向】是你的"北极星"，必须：

1. 每次生成任务前，先回顾【核心方向】
2. 每个任务必须与【核心方向】强相关
3. 每10个任务，检查是否偏离【核心方向】
4. 发现偏离立即纠正，不要继续

示例：
【核心方向】："编写Agent优化改进方案文档"

✅ 正确任务：
  - "Context压缩优化方案"
  - "工具调用控制方案"
  - "成本控制方案"
  → 都是"Agent优化"相关

❌ 错误任务（偏离方向）：
  - "前端UI美化方案" ← 偏离了（不是Agent优化）
  - "数据库设计方案" ← 偏离了
  - "用户权限方案" ← 偏离了
  → 应该立即停止并纠正

记忆口诀：
  "每生成一个任务，问自己：这符合【核心方向】吗？"
  "不符合 = 不生成！"

注意事项：
⚠️ 你不能直接操作文件！只能通过send_request让执行Agent去做
⚠️ 保持任务与【核心方向】的强相关性（最重要！）
⚠️ 避免生成重复任务
⚠️ 质量优先于数量
⚠️ 发现偏离方向立即暂停并纠正

你的目标：在用户休息时，高效地生成大量高质量且【符合核心方向】的任务成果。
"""
```

---

## 🧭 核心机制：方向锚定与偏离防护（最重要！）

### 问题：方向漂移

```
用户睡前（19:00）："写Agent优化方案"
   ↓
托管Agent开始工作
   ↓
20:00 生成："Context管理方案" ✅ 正确
21:00 生成："工具调用优化方案" ✅ 正确
22:00 生成："性能监控方案" ✅ 正确
23:00 生成："前端UI优化方案" ⚠️ 开始偏离
00:00 生成："数据库设计方案" ❌ 完全偏离
01:00 生成："用户权限方案" ❌ 跑题了
   ↓
用户醒来（07:00）：😤 "我要的是Agent优化，你写的都是啥？"
```

**根因分析**：
1. Context累积 → 早期的"核心方向"被挤到后面
2. 生成惯性 → 顺着最近的话题继续，忘记最初目标
3. 缺乏锚点 → 没有定期回顾原始方向

---

### 解决方案：方向锚定系统

#### 1️⃣ 核心方向常驻（Anchor Message）

```python
# 用户启动托管模式时的输入
user_direction = "编写Agent优化和改进相关的方案文档"

# 构建锚点消息（永远在Context最前面）
DIRECTION_ANCHOR = {
    "role": "system",
    "content": f"""🎯🎯🎯 核心方向（永远记住）🎯🎯🎯

用户在启动托管模式前给出的核心方向：
【{user_direction}】

这是你的"北极星"！
- 每生成一个任务前，先问：符合这个方向吗？
- 每10个任务，回顾一次这个方向
- 发现偏离，立即停止并纠正

不符合【核心方向】的任务 = 不要生成！
"""
}

# 托管Agent的messages结构
messages = [
    DIRECTION_ANCHOR,  # ← 锚点，永远第一条
    {"role": "system", "content": AUTONOMOUS_AGENT_PROMPT},
    {"role": "user", "content": "识别到的工作模式..."},
    ... # 后续对话
]

# 关键：即使Context压缩，也永远保留DIRECTION_ANCHOR
```

---

#### 2️⃣ 定期方向回顾（Periodic Direction Review）

```python
# 每N个任务强制回顾方向
REVIEW_INTERVAL = 10  # 每10个任务

if executed_count % REVIEW_INTERVAL == 0:
    # 强制插入方向回顾消息
    messages.append({
        "role": "user",
        "content": f"""⚠️ 定期方向检查（第{executed_count}个任务）

请回顾核心方向：【{user_direction}】

检查最近{REVIEW_INTERVAL}个任务：
{format_recent_tasks(recent_tasks)}

问题：
1. 这些任务是否都符合核心方向？
2. 是否出现偏离？
3. 下一步应该继续还是调整？

请用detect_pattern工具分析，并决定是否继续。
"""
    })
```

---

#### 3️⃣ 实时偏离检测（Drift Detection）

```python
class DirectionDriftDetector:
    """方向偏离检测器"""
    
    def __init__(self, core_direction: str):
        """
        Args:
            core_direction: 用户的核心方向
        """
        self.core_direction = core_direction
        self.direction_keywords = self._extract_keywords(core_direction)
    
    def _extract_keywords(self, direction: str) -> List[str]:
        """提取核心方向的关键词"""
        # 示例："编写Agent优化改进方案文档"
        # 提取：["Agent", "优化", "改进", "方案"]
        
        keywords = []
        # 移除停用词
        stopwords = ["的", "和", "与", "等", "编写", "撰写"]
        
        for word in direction.split():
            if word not in stopwords and len(word) > 1:
                keywords.append(word)
        
        return keywords
    
    def check_relevance(self, task_title: str, task_description: str) -> Dict:
        """
        检查任务与核心方向的相关性
        
        Returns:
            {
                "relevance_score": 0.85,  # 0-1
                "is_relevant": true,
                "matched_keywords": ["Agent", "优化"],
                "warning": null
            }
        """
        
        # 方法1：关键词匹配
        task_text = (task_title + " " + task_description).lower()
        
        matched = []
        for keyword in self.direction_keywords:
            if keyword.lower() in task_text:
                matched.append(keyword)
        
        keyword_score = len(matched) / len(self.direction_keywords)
        
        # 方法2：语义相似度（可选，用MiniMax）
        semantic_score = self._semantic_similarity(
            self.core_direction,
            task_title
        )
        
        # 综合评分
        relevance_score = keyword_score * 0.4 + semantic_score * 0.6
        
        # 判断
        is_relevant = relevance_score >= 0.6  # 阈值60%
        
        warning = None
        if relevance_score < 0.4:
            warning = f"任务严重偏离核心方向(相关度{relevance_score*100:.0f}%)"
        elif relevance_score < 0.6:
            warning = f"任务可能偏离核心方向(相关度{relevance_score*100:.0f}%)"
        
        return {
            "relevance_score": relevance_score,
            "is_relevant": is_relevant,
            "matched_keywords": matched,
            "warning": warning
        }
    
    def _semantic_similarity(self, text1: str, text2: str) -> float:
        """计算语义相似度（用MiniMax）"""
        
        prompt = f"""计算以下两段文本的语义相关度（0-1）：

文本1（核心方向）：{text1}
文本2（任务标题）：{text2}

只返回0-1之间的数字，表示相关程度。
1.0 = 完全相关
0.5 = 部分相关
0.0 = 完全无关
"""
        
        response = minimax.chat([{"role": "user", "content": prompt}])
        
        try:
            score = float(response.get("content", "0.5").strip())
            return max(0.0, min(1.0, score))
        except:
            return 0.5  # 默认中等相关
```

---

#### 4️⃣ 强制方向纠偏（Auto Correction）

```python
# 在generate_tasks工具执行后，检查所有生成的任务
def validate_generated_tasks(tasks: List[Dict], core_direction: str) -> List[Dict]:
    """验证生成的任务，过滤偏离方向的"""
    
    detector = DirectionDriftDetector(core_direction)
    
    validated_tasks = []
    rejected_tasks = []
    
    for task in tasks:
        check_result = detector.check_relevance(
            task["title"],
            task["description"]
        )
        
        if check_result["is_relevant"]:
            # 附加相关度信息
            task["relevance_score"] = check_result["relevance_score"]
            validated_tasks.append(task)
        else:
            # 拒绝偏离的任务
            rejected_tasks.append({
                "task": task,
                "reason": check_result["warning"]
            })
    
    # 记录日志
    if rejected_tasks:
        print(f"[DirectionGuard] ⚠️ 拒绝了{len(rejected_tasks)}个偏离方向的任务")
        for rt in rejected_tasks:
            print(f"  ❌ {rt['task']['title']}: {rt['reason']}")
    
    # 如果大部分任务都被拒绝 → 说明严重偏离
    if len(rejected_tasks) / len(tasks) > 0.5:
        print(f"[DirectionGuard] 🚨 严重偏离警告：{len(rejected_tasks)}/{len(tasks)}个任务被拒")
        # 触发强制纠偏
        trigger_forced_correction()
    
    return validated_tasks


def trigger_forced_correction():
    """强制纠偏：重新注入核心方向"""
    
    # 强制插入纠偏消息
    correction_message = {
        "role": "user",
        "content": f"""🚨 方向偏离警告！

你生成的任务中超过50%偏离了核心方向。

请立即：
1. 重新阅读【核心方向】：{user_direction}
2. 调用detect_pattern重新识别工作模式
3. 确保后续任务与核心方向强相关

如果无法生成符合方向的任务，请调用pause_autonomous暂停。
"""
    }
    
    messages.append(correction_message)
```

---

#### 5️⃣ 方向相关度监控（Continuous Monitoring）

```python
class DirectionComplianceMonitor:
    """方向遵守度监控器"""
    
    def __init__(self, core_direction: str):
        self.core_direction = core_direction
        self.task_history = []
        
    def record_task(self, task: Dict, relevance_score: float):
        """记录任务及其相关度"""
        self.task_history.append({
            "task": task,
            "relevance": relevance_score,
            "timestamp": time.time()
        })
    
    def get_compliance_trend(self, window_size: int = 10) -> Dict:
        """获取方向遵守度趋势"""
        
        recent_tasks = self.task_history[-window_size:]
        
        if not recent_tasks:
            return {"trend": "unknown", "avg_relevance": 0}
        
        # 计算平均相关度
        avg_relevance = sum(t["relevance"] for t in recent_tasks) / len(recent_tasks)
        
        # 趋势分析
        if len(recent_tasks) >= 2:
            first_half = recent_tasks[:len(recent_tasks)//2]
            second_half = recent_tasks[len(recent_tasks)//2:]
            
            avg_first = sum(t["relevance"] for t in first_half) / len(first_half)
            avg_second = sum(t["relevance"] for t in second_half) / len(second_half)
            
            if avg_second > avg_first + 0.1:
                trend = "improving"
            elif avg_second < avg_first - 0.1:
                trend = "declining"  # ← 警告！
            else:
                trend = "stable"
        else:
            trend = "unknown"
        
        return {
            "trend": trend,
            "avg_relevance": avg_relevance,
            "需要纠偏": avg_relevance < 0.6 or trend == "declining"
        }
```

---

## 🔒 方向保护的多重机制

### 机制汇总

| 机制 | 触发时机 | 作用 | 强度 |
|------|---------|------|------|
| **锚点消息** | 永久存在 | 提醒核心方向 | ⭐⭐⭐ |
| **System Prompt强调** | 每次调用 | 强化规则 | ⭐⭐⭐⭐ |
| **生成后过滤** | 每批任务 | 拒绝偏离任务 | ⭐⭐⭐⭐⭐ |
| **定期回顾** | 每10个任务 | 主动检查 | ⭐⭐⭐⭐⭐ |
| **趋势监控** | 实时 | 预警偏离 | ⭐⭐⭐⭐ |
| **强制纠偏** | 偏离50%+ | 重置方向 | ⭐⭐⭐⭐⭐ |

---

### 工具8: verify_direction（新增：方向验证工具）

```python
{
    "name": "verify_direction",
    "description": "验证即将生成的任务是否符合核心方向，在send_request之前调用",
    "parameters": {
        "type": "object",
        "properties": {
            "task_title": {
                "type": "string",
                "description": "待验证的任务标题"
            },
            "task_description": {
                "type": "string",
                "description": "任务描述"
            },
            "核心方向": {
                "type": "string",
                "description": "重复核心方向（强化记忆）"
            },
            "relevance_analysis": {
                "type": "object",
                "properties": {
                    "is_relevant": {"type": "boolean"},
                    "relevance_score": {"type": "number"},
                    "reasoning": {"type": "string"},
                    "matched_keywords": {"type": "array", "items": {"type": "string"}}
                }
            },
            "decision": {
                "type": "string",
                "enum": ["approve", "reject", "uncertain"],
                "description": "是否批准此任务"
            }
        },
        "required": ["task_title", "核心方向", "relevance_analysis", "decision"]
    }
}

# 强制流程：
# generate_tasks → verify_direction → send_request
#                         ↓ reject
#                    丢弃，不发送
```

---

### 使用verify_direction的强制流程

```python
# 托管Agent的工作流程（强制方向验证）

1. generate_tasks → 生成10个候选
2. for each task:
     verify_direction(task)
     if decision == "approve":
         send_request(task)  ✅
     else:
         skip  ❌ 不发送
3. 如果连续3个任务都被reject → 触发detect_pattern重新识别
```

---

## 🔍 模块1：工作模式识别器

### 功能：分析用户正在做什么

```python
# core/pattern_recognizer.py

class WorkPatternRecognizer:
    """工作模式识别器"""
    
    def analyze_recent_activity(
        self, 
        recent_messages: List[Dict],
        recent_tasks: List[Dict]
    ) -> Dict:
        """
        分析最近的活动模式
        
        Returns:
            {
                "pattern_type": "document_generation",
                "主题": "方案文档编写",
                "重复操作": ["创建md文件", "写入方案内容"],
                "目标目录": "docs/about2Do",
                "文件模式": "*.md",
                "estimated_topic_pool": 15,  # 预估还能生成多少个
                "confidence": 0.92
            }
        """
        
        # 调用LLM分析
        analysis_prompt = f"""分析以下最近的对话和任务，识别用户的工作模式。

最近对话（最近5轮）：
{format_messages(recent_messages)}

最近任务（最近10个）：
{format_tasks(recent_tasks)}

请识别：
1. 用户在重复做什么？
2. 工作主题是什么？
3. 涉及哪些文件/目录？
4. 还能生成多少类似的任务？

返回JSON格式：
{{
    "pattern_type": "document_generation/code_refactoring/testing/...",
    "主题": "简短描述",
    "重复操作": ["操作1", "操作2"],
    "目标目录": "相关目录",
    "estimated_topic_pool": 10,
    "confidence": 0.85
}}
"""
        
        response = llm.chat([
            {"role": "user", "content": analysis_prompt}
        ])
        
        return parse_pattern_analysis(response)
```

---

## 🎯 模块2：自主任务生成器

### 功能：基于模式生成新任务

```python
# core/task_generator.py

class AutonomousTaskGenerator:
    """自主任务生成器"""
    
    def generate_next_tasks(
        self,
        pattern: Dict,
        已生成任务: List[str],
        max_tasks: int = 100
    ) -> List[Dict]:
        """
        基于工作模式生成下一批任务
        
        Args:
            pattern: 工作模式分析结果
            已生成任务: 已经生成过的任务列表（避免重复）
            max_tasks: 最多生成多少个
            
        Returns:
            新任务列表
        """
        
        generation_prompt = f"""基于以下工作模式，生成5-10个相关的新任务。

工作模式：
- 主题：{pattern['主题']}
- 类型：{pattern['pattern_type']}
- 已完成：{len(已生成任务)}个任务

已生成的任务（避免重复）：
{chr(10).join(f'- {t}' for t in 已生成任务[-20:])}

要求：
1. 生成与主题高度相关的新任务
2. 不要重复已生成的
3. 保持创新性和实用性
4. 按优先级排序

示例（方案文档生成场景）：
如果主题是"Agent优化方案"，可以生成：
- "多模型切换方案"
- "流式输出优化方案"  
- "并发执行方案"
- "缓存策略方案"
等等

返回JSON格式：
[
    {{
        "title": "任务标题",
        "description": "详细描述",
        "priority": 8,
        "estimated_value": 7,
        "reasoning": "为什么生成这个任务"
    }},
    ...
]
"""
        
        response = llm.chat([
            {"role": "system", "content": "你是创意任务生成专家"},
            {"role": "user", "content": generation_prompt}
        ])
        
        new_tasks = parse_generated_tasks(response)
        
        # 过滤已存在的（双重检查）
        filtered_tasks = [
            t for t in new_tasks
            if not self._is_duplicate(t, 已生成任务)
        ]
        
        return filtered_tasks[:max_tasks]
    
    def _is_duplicate(self, new_task: Dict, existing_tasks: List[str]) -> bool:
        """检测任务是否重复"""
        
        new_title = new_task["title"].lower()
        
        for existing in existing_tasks:
            # 简单相似度检测
            if self._similarity(new_title, existing.lower()) > 0.7:
                return True
        
        return False
    
    def _similarity(self, s1: str, s2: str) -> float:
        """计算字符串相似度（简单版）"""
        # 可以用编辑距离或其他算法
        common_words = set(s1.split()) & set(s2.split())
        total_words = set(s1.split()) | set(s2.split())
        
        if not total_words:
            return 0.0
        
        return len(common_words) / len(total_words)
```

---

## 🤖 模块3：自动执行引擎

### 托管模式主循环

```python
# core/autonomous_mode.py

class AutonomousExecutor:
    """托管模式执行引擎"""
    
    def __init__(self, agent: Agent):
        self.agent = agent
        self.pattern_recognizer = WorkPatternRecognizer()
        self.task_generator = AutonomousTaskGenerator()
        
        # 安全限制
        self.max_tasks = 100           # 最多生成100个任务
        self.max_runtime_hours = 8     # 最多运行8小时
        self.max_cost = 10.0           # 最多花费¥10
        self.safety_check_interval = 10 # 每10个任务检查一次
        
        # 状态
        self.is_running = False
        self.generated_tasks = []
        self.executed_tasks = []
        self.total_cost = 0.0
    
    async def start_autonomous_mode(
        self,
        context_history: List[Dict],
        config: Dict
    ) -> Dict:
        """
        启动托管模式
        
        Args:
            context_history: 当前对话历史
            config: 托管配置
                {
                    "max_tasks": 50,
                    "max_hours": 4,
                    "max_cost": 5.0,
                    "quality_threshold": 7.0
                }
        """
        
        print(f"\n{'='*80}")
        print("🤖 托管模式启动")
        print(f"{'='*80}\n")
        
        # 应用配置
        self.max_tasks = config.get("max_tasks", 100)
        self.max_runtime_hours = config.get("max_hours", 8)
        self.max_cost = config.get("max_cost", 10.0)
        quality_threshold = config.get("quality_threshold", 7.0)
        
        self.is_running = True
        start_time = time.time()
        
        # ========== 步骤1：识别工作模式 ==========
        pattern = self.pattern_recognizer.analyze_recent_activity(
            recent_messages=context_history[-10:],
            recent_tasks=self.agent.get_recent_tasks()
        )
        
        print(f"[Autonomous] 识别到工作模式:")
        print(f"  类型: {pattern['pattern_type']}")
        print(f"  主题: {pattern['主题']}")
        print(f"  置信度: {pattern['confidence']*100:.0f}%")
        
        if pattern['confidence'] < 0.7:
            return {
                "success": False,
                "message": "工作模式不够明确，无法启动托管模式",
                "suggestion": "请先明确当前的工作目标"
            }
        
        # ========== 步骤2：托管循环 ==========
        while self.is_running:
            # 检查停止条件
            elapsed_hours = (time.time() - start_time) / 3600
            
            if len(self.executed_tasks) >= self.max_tasks:
                print(f"[Autonomous] 达到任务数量上限({self.max_tasks})")
                break
            
            if elapsed_hours >= self.max_runtime_hours:
                print(f"[Autonomous] 达到运行时间上限({self.max_runtime_hours}小时)")
                break
            
            if self.total_cost >= self.max_cost:
                print(f"[Autonomous] 达到成本上限(¥{self.max_cost})")
                break
            
            # 生成新任务
            new_tasks = self.task_generator.generate_next_tasks(
                pattern=pattern,
                已生成任务=[t["title"] for t in self.generated_tasks],
                max_tasks=5  # 每次生成5个
            )
            
            if not new_tasks:
                print(f"[Autonomous] 无法生成更多任务，结束托管")
                break
            
            # 执行新任务
            for task in new_tasks:
                if not self.is_running:
                    break
                
                print(f"\n[Autonomous] 执行任务: {task['title']}")
                
                # 执行任务
                result = await self._execute_autonomous_task(task, pattern)
                
                # 记录
                self.generated_tasks.append(task)
                self.executed_tasks.append({
                    "task": task,
                    "result": result,
                    "timestamp": time.time()
                })
                
                # 更新成本
                self.total_cost += result.get("cost", 0)
                
                # 质量检查
                if result.get("quality_score", 0) < quality_threshold:
                    print(f"  ⚠️ 质量不达标({result['quality_score']:.1f}<{quality_threshold})")
                
                # 安全检查
                if len(self.executed_tasks) % self.safety_check_interval == 0:
                    if not await self._safety_check():
                        print(f"[Autonomous] 安全检查未通过，停止托管")
                        break
        
        # ========== 步骤3：生成总结报告 ==========
        report = self._generate_report()
        
        return {
            "success": True,
            "mode": "autonomous",
            "pattern": pattern,
            "tasks_generated": len(self.generated_tasks),
            "tasks_executed": len(self.executed_tasks),
            "total_cost": self.total_cost,
            "runtime_hours": (time.time() - start_time) / 3600,
            "report": report
        }
    
    async def _execute_autonomous_task(
        self, 
        task: Dict,
        pattern: Dict
    ) -> Dict:
        """执行单个自主生成的任务"""
        
        # 构建任务描述
        task_message = f"""基于当前工作模式，执行以下任务：

任务：{task['title']}
描述：{task['description']}
工作模式：{pattern['主题']}

请按照之前的模式完成此任务。
"""
        
        # 调用Agent执行
        result = await self.agent.run(
            user_message=task_message,
            context_history=[]  # 独立Context，不依赖历史
        )
        
        # 质量评估
        quality_score = await self._evaluate_quality(task, result)
        result["quality_score"] = quality_score
        result["cost"] = self._estimate_cost(result)
        
        return result
    
    async def _evaluate_quality(self, task: Dict, result: Dict) -> float:
        """评估任务执行质量（0-10分）"""
        
        evaluation_prompt = f"""评估以下任务的执行质量（0-10分）：

任务：{task['title']}
期望：{task['description']}

执行结果：
{result.get('message', '')[:500]}

评分标准：
- 10分：完美完成，超出预期
- 7-9分：完成质量高
- 5-6分：基本完成
- 3-4分：部分完成
- 0-2分：失败或质量差

只返回数字分数。
"""
        
        response = llm.chat([
            {"role": "user", "content": evaluation_prompt}
        ])
        
        try:
            score = float(response.get("content", "5").strip())
            return max(0.0, min(10.0, score))
        except:
            return 5.0
    
    async def _safety_check(self) -> bool:
        """安全检查"""
        
        # 检查1：是否生成了危险内容
        recent_results = self.executed_tasks[-10:]
        
        for item in recent_results:
            result = item["result"]
            
            # 检测危险操作
            if self._contains_dangerous_operations(result):
                print(f"[Safety] ⚠️ 检测到危险操作")
                return False
            
            # 检测重复失败
            if not result.get("success"):
                print(f"[Safety] ⚠️ 任务执行失败")
                # 连续3次失败 → 停止
                if self._count_consecutive_failures() >= 3:
                    return False
        
        # 检查2：成本是否异常
        if self.total_cost > self.max_cost * 0.9:
            print(f"[Safety] ⚠️ 接近成本上限")
            return False
        
        return True
    
    def _generate_report(self) -> str:
        """生成托管执行报告"""
        
        # 统计
        total_generated = len(self.generated_tasks)
        total_executed = len(self.executed_tasks)
        successful = sum(1 for t in self.executed_tasks if t["result"].get("success"))
        
        high_quality = sum(
            1 for t in self.executed_tasks 
            if t["result"].get("quality_score", 0) >= 8.0
        )
        
        # 生成Markdown报告
        report = f"""# 托管模式执行报告

## 📊 执行统计

- **生成任务**: {total_generated}个
- **执行任务**: {total_executed}个
- **成功率**: {successful/total_executed*100:.1f}%
- **高质量**: {high_quality}个 (评分≥8.0)
- **总成本**: ¥{self.total_cost:.4f}
- **运行时长**: {self._get_runtime():.1f}小时

## 📋 任务清单

### ✅ 高质量任务 (推荐执行)

{self._format_high_quality_tasks()}

### ⚠️ 中等质量任务 (可选执行)

{self._format_medium_quality_tasks()}

### ❌ 低质量任务 (建议忽略)

{self._format_low_quality_tasks()}

## 💡 建议

{self._generate_suggestions()}
"""
        
        return report
```

---

## 🎨 托管模式配置界面

### UI设计

```html
<div class="autonomous-mode-panel">
    <div class="panel-header">
        <h3>🤖 托管模式</h3>
        <div class="status-badge" id="auto-status">
            未激活
        </div>
    </div>
    
    <div class="panel-body">
        <!-- 工作模式识别结果 -->
        <div class="pattern-detected" id="pattern-info">
            <h4>识别到的工作模式</h4>
            <div class="pattern-card">
                <div class="pattern-type">📝 方案文档编写</div>
                <div class="pattern-details">
                    <span>已完成: 6个方案</span>
                    <span>预估还能生成: 15个</span>
                    <span>置信度: 92%</span>
                </div>
            </div>
        </div>
        
        <!-- 配置选项 -->
        <div class="autonomous-config">
            <h4>⚙️ 托管配置</h4>
            
            <label>
                最大任务数
                <input type="number" id="auto-max-tasks" value="50" min="5" max="200">
            </label>
            
            <label>
                运行时长（小时）
                <input type="number" id="auto-max-hours" value="4" min="0.5" max="24" step="0.5">
            </label>
            
            <label>
                成本上限（元）
                <input type="number" id="auto-max-cost" value="5.00" min="0.5" max="50" step="0.5">
            </label>
            
            <label>
                质量阈值（0-10）
                <input type="range" id="auto-quality" value="7" min="5" max="10" step="0.5">
                <span id="quality-value">7.0</span>
            </label>
        </div>
        
        <!-- 预估 -->
        <div class="autonomous-estimate">
            <h4>📊 预估</h4>
            <div class="estimate-grid">
                <div class="estimate-item">
                    <span class="label">预计生成</span>
                    <span class="value">~45个任务</span>
                </div>
                <div class="estimate-item">
                    <span class="label">预计耗时</span>
                    <span class="value">~3.5小时</span>
                </div>
                <div class="estimate-item">
                    <span class="label">预计成本</span>
                    <span class="value">¥3.80</span>
                </div>
            </div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="autonomous-actions">
            <button class="btn-primary btn-large" onclick="startAutonomousMode()">
                🚀 启动托管模式
            </button>
            <button class="btn-danger" onclick="stopAutonomousMode()" disabled id="btn-stop">
                ⏸️ 停止托管
            </button>
        </div>
        
        <!-- 实时进度 -->
        <div class="autonomous-progress" id="auto-progress" style="display:none;">
            <h4>⏳ 执行中...</h4>
            <div class="progress-stats">
                <div>已生成: <strong id="tasks-generated">0</strong> / 50</div>
                <div>已执行: <strong id="tasks-executed">0</strong> / 50</div>
                <div>成功率: <strong id="success-rate">0%</strong></div>
                <div>已用成本: <strong id="cost-used">¥0.00</strong></div>
                <div>运行时长: <strong id="runtime">0分钟</strong></div>
            </div>
            
            <div class="latest-task">
                <strong>最新任务:</strong>
                <span id="latest-task-title">-</span>
            </div>
        </div>
    </div>
</div>
```

---

## 🛡️ 安全机制

### 多重安全边界

```python
class SafetyController:
    """托管模式安全控制器"""
    
    # 危险操作黑名单
    DANGEROUS_OPERATIONS = [
        "delete_file",           # 删除文件
        "run_terminal",          # 终端命令（除非白名单）
        "edit_file.*\.env",      # 修改环境变量
        "write_file.*config",    # 修改配置（需谨慎）
    ]
    
    # 允许的文件操作范围
    ALLOWED_DIRECTORIES = [
        "docs/about2Do/",        # 方案文档目录
        "temp/",                 # 临时目录
        "output/autonomous/"     # 托管输出目录
    ]
    
    def validate_autonomous_task(self, task: Dict) -> tuple[bool, str]:
        """验证自主任务是否安全"""
        
        # 检查1：操作类型
        if self._contains_dangerous_op(task):
            return False, "包含危险操作"
        
        # 检查2：文件范围
        if not self._within_allowed_dirs(task):
            return False, "操作超出允许范围"
        
        # 检查3：任务合理性
        if not self._is_reasonable_task(task):
            return False, "任务不合理"
        
        return True, "安全"
    
    def monitor_execution(self, executed_tasks: List[Dict]) -> Dict:
        """监控执行状态"""
        
        alerts = []
        
        # 监控1：重复率
        duplicate_rate = self._calculate_duplicate_rate(executed_tasks)
        if duplicate_rate > 0.3:
            alerts.append({
                "level": "warning",
                "message": f"任务重复率高({duplicate_rate*100:.0f}%)"
            })
        
        # 监控2：失败率
        failure_rate = self._calculate_failure_rate(executed_tasks)
        if failure_rate > 0.3:
            alerts.append({
                "level": "error",
                "message": f"任务失败率高({failure_rate*100:.0f}%)"
            })
        
        # 监控3：质量下降
        if self._is_quality_declining(executed_tasks):
            alerts.append({
                "level": "warning",
                "message": "任务质量持续下降"
            })
        
        return {
            "status": "error" if any(a["level"] == "error" for a in alerts) else "ok",
            "alerts": alerts
        }
```

---

## 📊 托管执行示例

### 场景：方案文档生成

```
19:30 用户启动托管模式
配置：
  - max_tasks: 50
  - max_hours: 8
  - max_cost: ¥5.00
  - quality_threshold: 7.0

识别模式：
  - 类型: document_generation
  - 主题: Agent优化方案文档
  - 目标目录: docs/about2Do/
  - 已完成: 6个

─────────────────────────────────────────

19:35 第1批任务生成（5个）
  1. "API限流与降级方案"
  2. "多模型负载均衡方案"  
  3. "缓存策略设计方案"
  4. "并发执行优化方案"
  5. "流式输出实现方案"

19:36 开始执行Task 1
  → 成功，质量评分: 8.5
  → 成本: ¥0.08
  
19:41 开始执行Task 2
  → 成功，质量评分: 8.2
  → 成本: ¥0.09
  
... (持续执行)

21:00 第2批任务生成（5个）
  6. "Agent集群部署方案"
  7. "版本管理与回滚方案"
  ...

... (持续到停止条件)

03:00 达到任务数量上限(50个)
或
07:00 达到运行时长上限(8小时)
或
提前达到成本上限

─────────────────────────────────────────

生成报告：
  ✅ 成功生成: 47个方案
  ✅ 高质量: 35个 (≥8.0分)
  ⚠️ 中等质量: 10个 (6.0-7.9分)
  ❌ 低质量: 2个 (<6.0分)
  💰 总成本: ¥4.82
  ⏱️ 运行时长: 7.5小时
```

---

## 🎯 任务生成策略

### 扩散式生成（避免重复）

```python
class TaskGenerationStrategy:
    """任务生成策略"""
    
    def generate_with_diversity(
        self,
        base_theme: str,
        已生成: List[str]
    ) -> List[Dict]:
        """
        扩散式生成（保证多样性）
        
        策略：
        1. 核心主题的直接变体（3个）
        2. 相关领域的横向扩展（2个）
        3. 深度挖掘的纵向扩展（2个）
        4. 创新性探索（1个）
        """
        
        generation_prompt = f"""基于主题"{base_theme}"，生成8个多样化的任务。

已生成：
{chr(10).join(已生成[-20:])}

生成策略：
1. 核心变体（3个）：主题的不同角度
   示例：如果主题是"Context管理"
   → "Context压缩算法"
   → "Context并发访问"
   → "Context持久化"

2. 横向扩展（2个）：相关但不同的领域
   → "Memory管理方案"
   → "Cache策略设计"

3. 纵向深挖（2个）：某个点的深入
   → "Context压缩的LZ4算法实现"
   → "Context的向量化检索"

4. 创新探索（1个）：大胆的新想法
   → "基于图神经网络的Context重要度预测"

要求：
- 与主题相关但不重复
- 有实际价值
- 技术可行

返回JSON数组。
"""
        
        response = llm.chat([{"role": "user", "content": generation_prompt}])
        return parse_tasks(response)
```

---

## ⏸️ 用户控制机制

### 中断与恢复

```python
class AutonomousExecutor:
    
    def pause(self):
        """暂停托管模式"""
        self.is_running = False
        print("[Autonomous] 已暂停")
        
        # 保存当前状态
        self._save_state()
    
    def resume(self):
        """恢复托管模式"""
        # 加载状态
        self._load_state()
        
        self.is_running = True
        print("[Autonomous] 已恢复")
        
        # 继续执行
        asyncio.create_task(self._continue_execution())
    
    def stop(self):
        """完全停止"""
        self.is_running = False
        
        # 生成报告
        report = self._generate_report()
        
        # 保存报告
        self._save_report(report)
        
        print("[Autonomous] 已停止，报告已生成")
```

---

## 📱 实时通知

### 阶段性通知用户

```python
class AutonomousNotifier:
    """托管模式通知器"""
    
    NOTIFICATION_EVENTS = [
        "每10个任务",
        "每1小时",
        "达到50%进度",
        "发现高质量结果",
        "出现安全警告"
    ]
    
    def notify(self, event: str, data: Dict):
        """发送通知"""
        
        # 可以通过多种方式通知
        # 1. 前端Toast（如果前端开着）
        # 2. 系统通知（Windows通知）
        # 3. 邮件（可选）
        # 4. 企业微信/钉钉（可选）
        
        message = self._format_notification(event, data)
        
        # 前端通知
        if frontend_connected:
            send_to_frontend({
                "type": "autonomous_notification",
                "event": event,
                "message": message,
                "data": data
            })
        
        # Windows通知
        self._show_windows_notification(message)
```

---

## ⚠️ 风险与挑战

### 风险1：任务质量下降

```
问题：
  生成50个任务，后面的质量越来越差
  → 重复、无意义的任务

解决：
  ✅ 质量阈值：低于7分停止生成
  ✅ 相似度检测：重复的不生成
  ✅ 人工审核：高质量任务人工筛选
```

### 风险2：资源失控

```
问题：
  运行一晚上，成本爆炸

解决：
  ✅ 成本上限：¥10硬性限制
  ✅ 时间上限：8小时自动停止
  ✅ 实时监控：每10个任务检查一次
```

### 风险3：生成危险操作

```
问题：
  自主生成了删除文件的任务

解决：
  ✅ 操作白名单：只允许安全操作
  ✅ 目录限制：只能在指定目录
  ✅ 人工审核：危险操作需确认
```

---

## 🎯 实施路线图

### Phase 1: MVP（3天）
- [ ] WorkPatternRecognizer
- [ ] AutonomousTaskGenerator
- [ ] 基础执行循环
- [ ] 简单安全检查

### Phase 2: 安全与控制（2天）
- [ ] SafetyController
- [ ] 多重安全边界
- [ ] 暂停/恢复机制
- [ ] 质量评估

### Phase 3: 用户体验（2天）
- [ ] 前端控制界面
- [ ] 实时进度展示
- [ ] 通知系统
- [ ] 报告生成

### Phase 4: 优化完善（3天）
- [ ] 任务去重优化
- [ ] 扩散式生成
- [ ] 成本优化
- [ ] 监控Dashboard

---

## 💡 创新亮点

1. **自主任务生成** - AI理解你在做什么，主动生成相关任务
2. **批量执行** - 无需人工干预，自动执行
3. **质量保证** - 自动评分，筛选高质量结果
4. **安全可控** - 多重边界，防止失控
5. **成本透明** - 实时监控，上限保护

---

## 📊 应用场景

### 场景1：方案文档批量生成
```
输入：让Agent写3个方案
托管：自动生成并执行50个相关方案
输出：50个方案，筛选20个有价值的
```

### 场景2：代码重构任务
```
输入：重构auth模块
托管：自动生成相关重构子任务
  - 提取公共函数
  - 统一错误处理
  - 添加类型注解
  - 优化导入
  ...
```

### 场景3：测试用例生成
```
输入：为某个模块写测试
托管：自动生成全面的测试用例
  - 正常流程测试
  - 边界条件测试
  - 异常处理测试
  - 性能测试
  ...
```

---

## 🎯 总结

### 核心价值

**让Agent真正"自主"工作，解放人力**

- 🤖 **自主生成**：理解工作模式，生成相关任务
- 🚀 **批量执行**：一次配置，持续工作
- 🎯 **质量保证**：自动评分筛选
- 🛡️ **安全可控**：多重限制防失控
- 💰 **成本透明**：预算控制

### 适用场景

✅ **批量创作**（方案、文档、代码模板）  
✅ **系统性优化**（重构、测试、文档补全）  
✅ **探索性任务**（多方案对比、技术调研）

### 风险评估

⚠️ **中高风险，需要严格的安全机制**

建议：
1. MVP先在受限环境测试
2. 逐步放开权限
3. 持续监控优化

**这是一个大胆且有价值的创新！** 🌟🚀🤖

---

## 💭 哲学思考

这个功能让Agent从"工具"进化为"同事"：
- 不再是被动等待指令
- 而是主动理解工作、生成任务、自主执行
- 人类只需定义方向和边界
- Agent在边界内自主探索

**这是通往AGI的一小步！** 🎯

